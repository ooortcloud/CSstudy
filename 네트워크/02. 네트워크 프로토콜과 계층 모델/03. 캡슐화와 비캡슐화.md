캡슐화 역시 OOP에서 등장한 핵심 특징 중 하나이지만, 네트워크에서도 캡슐화를 매우 적극적으로 사용한다. 어떻게 사용되는지 이번 장에서 알아보자.

## 캡슐화(Encapsulation)

**송신 호스트에서 수신 호스트로 데이터가 전송될 때 각 계층을 거치면서 헤더 정보를 추가하는 과정.** 상위 계층에서 하위 계층으로 데이터를 전달할 때마다, 각 계층에서 자신의 프로토콜에 필요한 정보들을 header 형태로 덧붙여서 데이터 크기가 점점 불어나게 된다. 그래서 원본 데이터 크기가 작으면, 원본 데이터보다 header의 크기가 더 큰 배보다 배꼽이 더 큰 상황이 자주 연출된다. 

## 비캡슐화(Decapsulation)

캡슐화의 반대 과정으로, **수신 호스트에서 송신 호스트의 데이터를 받은 뒤, 원래의 데이터 형태로 복원하는 과정이다.** 하위 계층에서 상위 계층으로 데이터를 전달할 때마다, 각 계층에서 자신의 프로토콜에 필요한 정보들을 header로부터 추출하여 읽고 적절한 행동을 취하게 된다. 데이터는 계층으로 올라갈수록 전체 header의 크기가 점점 줄어들게 되며, 최상위 계층으로 올라오면 최종적으로 순수 데이터(원래의 형태)만 남게 된다.

## 왜 필요한가?

캡슐화의 필요성은 OOP와 맥을 같이 한다.

- **데이터 무결성 보장**: 각 계층에서 header 정보를 기반으로 데이터의 정확성 검증이 가능.
- **프로토콜 독립성**: 각 계층이 독립적으로 동작할 수 있어 유연성과 확장성을 챙길 수 있음.
- **보안 강화**: header 정보를 통해 데이터의 출처와 목적지를 확인할 수 있음.
- **효율적인 라우팅**: header 정보를 통해 효율적인 경로 선택이 가능.
