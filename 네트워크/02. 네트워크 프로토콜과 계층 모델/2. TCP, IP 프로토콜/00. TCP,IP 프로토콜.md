## TCP/IP

**TCP(Transmission Control Protocol)/IP(Internet Protocol)는 패킷 통신 방식 인터넷 프로토콜인 IP와, 패킷 전송 조절 프로토콜인 TCP로 이루어져 있다.** IP는 패킷 전달 여부를 보증하지 않기 때문에 패킷을 보낸 순서와 받는 순서가 다를 수 있다. 반면 TCP는 IP 위에서 동작하는 프로토콜로, 데이터의 전달을 보증하고 패킷을 보낸 순서대로 받게 하는 역할을 한다. 수많은 어플리케이션 프로토콜들은 TCP를 기반으로 한 IP 위에서 동작하기 때문에, TCP/IP로 묶어서 부르는 것이 관행이 됐다.

보다 자세한 내용은 저 아래에서 후술하겠다. 이 블록에서는 추상적인 시각으로만 설명한다.

### Layer로 이해하기

이들은 너무 유명한 프로토콜이기 때문에 OSI 7 계층에서 이들을 많이 참고한 것 같다. 따라서 OSI 7 계층에서 각 계층의 목적만 살펴보면 이들이 무엇을 수행하는지 쉽게 파악할 수 있다.

**Network Layer(L3)**

**네트워크 계층은 routing을 기반으로 packet들이 적절한 목적지에 도달할 수 있도록 돕는 역할을 수행한다.** 여기서 routing이란, source에서 한 endpoint에서 다른 endpoint로 packet을 전송하면 router에서 적절한 경로와 목적지를 찾아주는 기능이다. 이 계층에서는 packet 간의 관계를 이해하지 않으며, 오직 단일 packet을 목적지까지 제대로 보내는 것에만 중점을 둔다. IP가 네트워크 계층의 대표적인 프로토콜이다.

**Transport Layer(L4)**

**전송 계층은 송신자와 수신자의 논리적 연결(물리적으로 연결되어 있는 것처럼 느끼게 함)을 담당하는 부분으로, 신뢰성 있는 연결을 유지할 수 있도록 돕는 역할을 수행한다.** 주어진 역할을 수행하기 위해, endpoint 간의 연결을 생성하고 데이터를 얼마나 주고 받았고 모든 데이터를 누락이나 변질없이 제대로 받았는지 등을 모니터링한다. TCP와 UDP가 전송 계층의 대표적인 프로토콜이다.

## 신뢰성 있는 데이터 전송

**신뢰성 있는 데이터 전송은 송신자가 보낸 데이터가 손상되지 않으며 보낸 순서대로 수신자에게 전달되는 것을 보장하는 통신 방식이다.** 신뢰성 있는 데이터 전송은 다음과 같은 이유로 중요하다고 볼 수 있다:

- **데이터 정확성**: 웹 페이지 로딩, 파일 전송, 이메일 전송 등 사용자 입장에서 네트워크를 이용해 데이터를 보낼 때 데이터가 온전히 전달되는 것은 기본적인 요구사항이다.
- **네트워크 효율성**: 각 데이터 전송에 신뢰성이 보장되므로, 데이터 전송을 불필요하게 번복하지 않음으로써 네트워크 효율성이 높아진다.
- **어플리케이션 안정성**: OSI 7 계층 기준 전송 계층의 상위 계층에서는 신뢰할 수 있는 통신 채널을 이용하게 되므로, 데이터 전송 신뢰성 로직을 추가적으로 작성하지 않아도 안정적인 서비스 구현이 가능하게 한다.

신뢰성 있는 데이터 전송을 위해서는 여러 가지의 전략들이 존재하는데, 이는 바로 다음 내용에서 자세히 알아보도록 하자.

### 전송 후 대기 프로토콜(Stop-and-Wait Protocol)

**전송 후 대기 프로토콜은 가장 기본적이고 단순한 신뢰성 있는 데이터 전송 프로토콜이다.** 

#### 동작 과정

1. 송신자가 단일 패킷을 전송한다. 이때 송신자는 타이머를 시작하고 수신자의 응답을 기다리기 시작한다.
2. 수신자가 송신자로부터 패킷을 받으면 확인(ACK) 또는 부정(NAK) 신호를 송신자에게 보낸다.
3. 송신자는 다음 조건에 따라 다음 패킷을 전송할지 여부를 결정한다:
   - 송신자가 타이머 내에 수신자로부터 ACK를 받으면 다음 패킷을 전송한다.
   - 타임아웃되면 송신자는 이전에 보낸 패킷을 수신자에게 재전송한다.
   - 송신자가 타이머 내에 수신자로부터 NAK를 받으면, 타임아웃 때와 동일하게 송신자는 이전에 보낸 패킷을 수신자에게 재전송한다.

#### 장단점

**장점**

- 구현이 매우 간단하고 이해하기 쉽다.
- 패킷 손실이나 오류 발생 시에 즉각적인 재전송이 가능해 오류 복구가 빠르다.

**단점**

- 패킷 전송과 ACK 수신 사이의 대기 시간으로 인해 전체적인 처리량(throughput)이 낮다.
  - 링크의 실제 사용 시간 대비 대기 시간이 길어 채널 효율성이 떨어진다고도 표현할 수 있다.
- 송신자와 수신자 사이의 거리가 먼 경우 성능이 크게 저하된다.

전송 후 대기 프로토콜은 효율적인 면에서 문제가 있다. 이러한 단점을 해결하기 위해 슬라이딩 윈도우 프로토콜과 같은 복잡하지만 효율적인 방식들이 개발되었다.

### 파이프라인 프로토콜(Pipelined Protocol)

**파이프라인 프로토콜은 데이터 전송 효율을 높이기 위해서 여러 패킷을 연속적으로 전송하는 방식이다.** 이 방법은 슬라이딩 윈도우 프로토콜이 적용된 방법이다.(관련 내용은 아래에서 후술함) 슬라이딩 윈도우 프로토콜은 수신자로부터 ACK를 받기 전에 송신자가 전송할 수 있는 데이터의 최대 양을 규제하는 흐름 제어 메커니즘이다.

#### 동작 원리

1. 송신자는 수신자의 확인(ACK) 응답을 기다리지 않고 여러 패킷을 연속적으로 전송한다.
2. 송신자는 일정한 크기의 윈도우를 유지하며, 이 윈도우의 크기만큼 여러 개의 데이터 프레임을 연속적으로 전송한다.
   - 송신자는 수신자의 처리 속도를 고려하여 송신자의 전송 속도를 조절한다. 이 흐름 제어 작업이 선행돼야 수신자에게서 버퍼 오버 플로우가 발생하지 않는다.
3. 수신자는 윈도우의 크기에 맞춰 데이터를 수신하고 확인(ACK)를 보낸다. 그래서 하나의 ACK 응답으로 여러 개의 프레임에 대한 응답을 처리할 수 있다.
4. 송신자는 상황에 따라 다음과 같은 행동을 진행할 수 있다:
     - 데이터의 손실이나 손상이 감지되면, Go-Back-N이나 Selective Repeat와 같은 오류 제어 프로토콜을 사용하여 수신자에게 재전송을 수행한다.

파이프라인 프로토콜은 확실히 네트워크 성능을 향상시킬 수 있지만, 전과 달리 복잡성이 증가하고 오류 처리가 더 복잡해지는 문제가 있다. 참고로 최신 프로토콜인 HTTP/2에서 등장한 멀티플렉싱 기능은 이러한 단점을 보완하여 등장하였다.

#### 장점

- **네트워크 성능 향상**: 대기 시간을 확실히 줄여 더 빠르게 전송할 수 있고, 이는 네트워크 정체 현상을 줄여주어 전체적인 성능이 향상된다.
- **리소스 활용도 증가**: 대기 시간이 줄어들면서 네트워크 작업에 대한 CPU와 네트워크 리소스를 더 효율적으로 사용할 수 있게 된다.
- **처리량 증가**: 동시에 여러 패킷을 처리할 수 있게 되므로 전체적인 처리량이 증가한다.

단점은 구현하기 어려운 점이 핵심이자 전부이다.

### 슬라이딩 윈도우 프로토콜

**슬라이딩 윈도우 프로토콜은 데이터 통신에서 사용되는 흐름 제어 및 오류 제어 기법이다.** 송신자는 CWND(Congestion Window) 수신자는 RWND(Receive Window) 라는 버퍼를 가지며, 이 윈도우 크기에 다라 한 번에 전송 가능한 패킷 수가 결정된다. 각 패킷은 '순서 번호'를 통해 패킷을 구별한다.

#### 동작 방식

<p align="center">
  <img width="75%" height="75%" src="https://blog.kakaocdn.net/dn/IbVg5/btq4wvQ4Kbp/fl3xN6a2k0BMahx1GrOTuk/img.jpg">
</p>

1. 송신자는 자신의 윈도우 크기만큼 패킷을 연속으로 전송한다.
2. 수신자는 전송된 패킷을 받아 순서대로 윈도우에 저장한 뒤, ACK 메세지를 송신자에게 보낸다.
3. 송신자는 ACK를 받으면 자신의 윈도우를 오른쪽으로 이동시키면서, 윈도우 안에 새롭게 들어온 신규 패킷(아직 송신하지 않은 패킷)을 전송한다. 만약 특정 패킷이 타임아웃되면(제한 시간 내에 ACK를 받지 못하면) 재전송한다.
4. 수신자는 윈도우를 왼쪽으로 이동시키며 상위 계층으로 전달할 수 있는 패킷을 조회한다. 만약 순서대로 받지 못한 패킷이 있으면 송신자에게 해당 패킷에 대해 NAK를 보내서 재전송을 요청한다.
5. 송신자는 상황에 따라 다음과 같은 행동을 진행할 수 있다:
   - 데이터의 손실이나 손상이 감지되면, Go-Back-N이나 Selective Repeat와 같은 오류 제어 프로토콜을 사용하여 수신자에게 재전송을 수행한다.

#### 오류 복구 방식

**Go-Back-N(GBN)**:

- 오류 발생 시에 문제가 발생한 해당 패킷으로부터 현재 윈도우 끝까지 전송했던 모든 후속 패킷을 전부 재전송한다.
- 동작은 간단하나 불필요한 재전송이 발생할 수 있다.

**Selective Repeat**:

- 오류가 발생한 특정 패킷만 선택적으로 재전송한다.
- 효율적인 해결책이지만, 수신자 측에서 복잡한 버퍼 관리를 수행해야 하여 구현 난이도가 있다.

