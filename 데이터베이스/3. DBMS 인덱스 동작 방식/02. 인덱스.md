# 데이터베이스 인덱스: 빠른 데이터 검색을 위한 길잡이

> **Index:** 데이터베이스 테이블의 검색 성능을 향상시키는 자료구조

데이터베이스 인덱스는 책의 목차와 같은 역할을 합니다. 책에서 특정 내용을 찾을 때 목차를 먼저 보고 해당 페이지를 찾아가듯이, 데이터베이스에서도 인덱스를 사용하면 원하는 데이터를 빠르게 찾을 수 있습니다.

## 인덱스의 저장 위치

인덱스는 보통 테이블과 같은 디스크에 저장되지만, 별도의 인덱스 파일로 관리되기도 합니다. 예를 들어, MySQL의 MyISAM 엔진에서는 인덱스를 `.MYI` 파일로 저장하며, 일부 DBMS에서는 전용 테이블스페이스에 저장합니다.

별도의 파일로 관리하면 인덱스 크기가 증가해도 테이블 데이터와 독립적으로 최적화할 수 있지만, 파일 I/O가 늘어나면서 성능에 영향을 줄 수 있습니다.

인덱스를 디스크에 저장하는 이유는 데이터 지속성을 보장하기 위해서입니다. 만약 데이터 지속성이 필요 없다면, 캐시 서버를 활용하여 조회 속도를 높이는 것이 좋은 대안이 될 수 있습니다.

일반적으로 테이블을 생성하면, DBMS는 기본 키(PK) 컬럼에 대한 인덱스를 자동으로 생성하여 관리합니다.

## 인덱스의 역할

### 1. 빠른 데이터 검색

인덱스는 특정 컬럼의 값을 정렬하여 저장하는 자료구조입니다. 대표적으로 **B+ 트리 인덱스**는 데이터가 계층적으로 정렬되어 있어 범위 검색에 유리하며, **해시 인덱스**는 키-값 매핑을 이용해 정확한 값 검색에 최적화되어 있습니다. 이를 통해 데이터베이스는 전체 테이블을 순차 검색하는 것이 아니라, 인덱스를 이용하여 빠르게 원하는 데이터를 찾을 수 있습니다.

### 2. 정렬 및 그룹화 성능 향상

`ORDER BY` 또는 `GROUP BY` 절을 사용할 때, 인덱스가 존재하면 쿼리 성능이 크게 향상됩니다.

## 인덱스의 종류

### 1. B+ 트리 인덱스

가장 일반적으로 사용되는 인덱스 형태로, 범위 검색에 효율적입니다.

### 2. 해시 인덱스

정확한 값을 찾는 데 최적화되어 있지만, 범위 검색에는 적합하지 않습니다.

### 3. 비트맵 인덱스

특정 값의 존재 여부를 빠르게 확인하는 데 사용됩니다.

## 인덱스 설계 시 고려사항

인덱스는 데이터 검색 성능을 향상시키는 강력한 도구이지만, 무조건 사용한다고 좋은 것은 아닙니다. 인덱스를 적절히 설계하고 관리해야 최적의 성능을 유지할 수 있습니다.

- **과도한 인덱스 사용 주의**: 너무 많은 인덱스는 삽입, 수정, 삭제 성능을 저하시킬 수 있습니다.
- **디스크 공간 관리**: 불필요한 인덱스는 디스크 공간을 낭비하는 원인이 됩니다.
- **주기적인 점검 필요**: 인덱스 사용률을 주기적으로 점검하여 불필요한 인덱스를 제거하는 것이 중요합니다.

적절한 인덱스 설계를 통해 데이터베이스 성능을 최적화하고, 효과적으로 데이터 검색을 수행할 수 있도록 해야 합니다.

# 데이터베이스 인덱스의 개념과 작동 원리

데이터베이스에서 인덱스(Index)는 검색 성능을 향상시키는 핵심 요소입니다. 인덱스는 테이블의 특정 열(Column)에 대해 별도의 자료구조를 생성하여 검색 속도를 개선하는 역할을 합니다. 

### 인덱스의 자료구조

인덱스는 일반적으로 **B+ 트리(B+ Tree)** 또는 **해시(Hash Table)** 구조를 활용하여 저장됩니다.

- **B+ 트리 인덱스:**
  - 대부분의 관계형 데이터베이스에서 사용됩니다.
  - 범위 검색과 정렬된 데이터 접근에 유리합니다.
  - 디스크 I/O를 최소화하도록 설계되어 성능이 뛰어납니다.
  
- **해시 기반 인덱스:**
  - 특정 키 값을 빠르게 찾는 데 유리합니다.
  - 범위 검색이 불가능하여 비교적 단순한 조회에만 적합합니다.

## 인덱스의 저장 방식

### 1. 인덱스와 테이블의 저장 위치

- **테이블 데이터:** 디스크의 데이터 파일에 저장되며, 데이터베이스 관리 시스템(DBMS)이 이를 관리합니다.
- **인덱스 데이터:** 테이블 데이터와 별도로 저장되며, 일반적으로 인덱스 전용 파일이나 테이블스페이스에 위치합니다.
- **메모리 캐싱:** 자주 사용되는 인덱스는 DBMS의 버퍼 풀(Buffer Pool)에서 관리되어 성능을 향상시킵니다.

### 2. 인덱스의 논리적 참조

인덱스는 데이터의 **물리적 디스크 주소를 직접 가리키지 않고**, 내부적으로 관리되는 **논리적 참조(예: 페이지 ID, 레코드 슬롯 번호 등)**를 이용합니다. 따라서, 인덱스를 검색하면 데이터베이스는 해당 논리적 위치를 기반으로 실제 데이터를 조회합니다.

<iframe width="560" height="315" src="https://youtu.be/edpYzFgHbqs?feature=shared" frameborder="0" allowfullscreen></iframe>


## 인덱스의 동작 원리

### 1. 인덱스 생성 과정

특정 컬럼에 대해 인덱스를 생성하면, DBMS는 해당 컬럼 값을 정렬된 인덱스 구조로 구성하여 저장합니다. 주요 인덱스 유형은 다음과 같습니다:

- **클러스터드 인덱스 (Clustered Index)**
  - 테이블 자체가 인덱스의 정렬 순서에 맞게 저장됩니다.
  - 테이블당 하나만 생성할 수 있으며, 검색 성능이 우수합니다.
  - 리프 페이지에 실제 데이터가 저장된 페이지를 저장합니다.(ex. 백과사전 자체에는 사전식으로 실제 데이터가 저장되어 있음)

- **비클러스터드 인덱스 (Non-Clustered Index)**
  - 원본 데이터는 변경되지 않고, 인덱스만 별도로 관리됩니다.
  - 하나의 테이블에 여러 개의 비클러스터드 인덱스를 생성할 수 있습니다.
  - 리프 페이지에 실제 데이터를 가리키는 주소 페이지를 저장합니다.(ex. 별도의 찾아보기 페이지를 통해 빠르게 해당 내용이 존재하는 페이지 추적 가능)

### 2. 인덱스를 활용한 데이터 검색

1. 쿼리 실행 시, DBMS는 우선적으로 인덱스를 조회하여 검색 대상이 될 레코드를 선별합니다.
2. 인덱스를 통해 찾은 키 값을 따라가 논리적인 데이터 위치(예: 페이지 ID, 레코드 슬롯 번호)를 확인합니다.
3. 해당 데이터를 실제 테이블에서 조회하여 결과를 반환합니다.

이 과정은 **이진 탐색(Binary Search)**과 유사한 방식으로 동작하여, 전체 테이블을 검색하는 것보다 훨씬 빠르게 데이터를 찾을 수 있도록 합니다.

## 인덱스 설계 시 고려사항

인덱스는 데이터 검색 성능을 높이지만, 적절한 설계가 이루어지지 않으면 오히려 성능을 저하시킬 수 있습니다. 따라서 다음과 같은 요소를 고려해야 합니다:

- **과도한 인덱스 사용 지양:** 인덱스가 많아질수록 조회는 빨라지지만, 데이터 삽입·수정·삭제 작업의 성능이 저하될 수 있습니다.
- **저장 공간 고려:** 인덱스는 추가적인 저장 공간을 필요로 하므로, 디스크 용량과 성능의 균형을 고려해야 합니다.
- **쿼리 패턴 분석:** 자주 사용되는 조회 패턴을 분석하여 적절한 인덱스를 생성해야 합니다.
- **페이지 분할(페이지 스플릿) 최소화:** 클러스터드 인덱스 사용 시, 새로운 데이터가 삽입될 때 기존 페이지가 분할되면서 성능 저하가 발생할 수 있습니다. 이를 방지하려면 **FILLFACTOR** 설정을 적절히 조정해야 합니다.


# 인덱스 설정 시 주의사항

데이터베이스에서 **인덱스(Index)** 를 사용할 때 주의해야 할 점은 다음과 같습니다.

### 1️⃣ **인덱스가 항상 성능을 향상시키는 것은 아니다**

- **읽기 성능 향상**: 인덱스를 사용하면 `SELECT` 쿼리의 성능이 크게 향상됨.
- **쓰기 성능 저하**: `INSERT`, `UPDATE`, `DELETE` 시 인덱스를 관리해야 하므로 오버헤드 발생. 예를 들어, 트랜잭션이 많은 테이블에서 `INSERT`가 자주 발생하면, 각 데이터 삽입마다 인덱스도 갱신되어 성능 저하가 발생할 수 있다. 특히, 다중 인덱스가 존재하면 업데이트 비용이 증가하여 시스템 부하가 커질 수 있다.

💡 **주의할 점**\
👉 `SELECT` 가 많은 테이블에는 적절한 인덱스가 필요하지만, `INSERT/UPDATE/DELETE` 가 빈번한 테이블에는 인덱스를 과도하게 사용하면 성능이 저하될 수 있음.

---

### 2️⃣ **불필요한 인덱스는 오히려 역효과**

- **너무 많은 인덱스**: 데이터 변경 시 인덱스도 갱신해야 하므로 **쓰기 성능 저하** 발생.
- **중복된 인덱스**: 비슷한 컬럼 조합의 인덱스가 여러 개 존재하면 공간 낭비와 성능 저하 초래.

💡 **주의할 점**\
👉 사용되지 않는 인덱스는 제거하고, **실제 쿼리 패턴에 맞는 최소한의 인덱스**만 유지하는 것이 중요!

---

### 3️⃣ **올바른 인덱스 선택 (카디널리티 고려)**

- **카디널리티(Cardinality)**: 특정 컬럼에서 **중복되지 않는 값의 개수**를 의미.
- **카디널리티가 높은 컬럼** (예: `id`, `email`)을 인덱스로 사용하면 검색 성능이 좋아짐.
- **카디널리티가 낮은 컬럼** (예: `성별`, `Y/N`)을 인덱스로 사용하면 성능 향상이 크지 않음. (사실상 테이블 전체 조회를 하는 것과 비슷해서, 인덱스 테이블을 쓰는 의미가 없음)

💡 **주의할 점**\
👉 `성별`, `상태(Y/N)` 같은 이진 값 컬럼에 단독으로 인덱스를 걸어도 효과 없음.\
👉 대신, **범위 검색이 많은 경우 B-Tree 인덱스 활용**하면 좋음.

---

### 4️⃣ **인덱스가 걸린 컬럼에서 함수 사용 주의**

인덱스가 적용된 컬럼을 `LOWER()`, `UPPER()`, `DATE()` 같은 함수로 감싸면 **인덱스가 무효화**됨.

```sql
SELECT * FROM users WHERE LOWER(username) = 'kimlulu';
```

위 쿼리는 `username` 컬럼에 인덱스가 있더라도 사용되지 않음.

💡 **해결 방법**\
👉 **함수 기반 인덱스(Function-Based Index) 활용** (`MySQL 8.0+`, `PostgreSQL`, `Oracle`)\
👉 또는, **데이터를 미리 정규화하여 저장** (예: `LOWER(username)` 값을 별도 컬럼에 저장)

---

### 5️⃣ **복합 인덱스(Composite Index) 활용 시 주의점**

복합 인덱스는 여러 개의 컬럼을 조합하여 만든 인덱스지만, **사용하는 순서가 중요**함.

```sql
CREATE INDEX idx_user_name_age ON users (name, age);
```

- `WHERE name = 'Kim'` → **인덱스 사용 가능**
- `WHERE age = 30` → **인덱스 사용 안 됨** (name을 조건으로 먼저 걸어야 함)
- `WHERE name = 'Kim' AND age = 30` → **인덱스 전체 활용 가능**

💡 **주의할 점**\
👉 복합 인덱스는 **첫 번째 컬럼을 조건으로 사용해야 인덱스가 적용**됨.&#x20;



💡 **팁**\
👉 특정 쿼리에서 모든 요청된 컬럼이 복합 인덱스에 포함되어 있다면, 예를 들어, 다음과 같은 쿼리가 있다고 가정하자.

```sql
SELECT name, age FROM users WHERE name = 'Kim' AND age = 30;
```

이 경우, `idx_user_name_age (name, age)` 복합 인덱스가 존재한다면, 테이블을 직접 조회하지 않고 인덱스만으로 결과를 반환할 수 있다. 이를 **Covering Index**라고 하며, 테이블 I/O를 줄여 쿼리 성능을 크게 향상시킬 수 있다

---

### 6️⃣ **LIKE 연산에서 와일드카드 위치 주의**

- `LIKE '%kim%'` → **인덱스 사용 불가** (앞에 `%`가 있으면 풀 테이블 스캔 발생)
- `LIKE 'kim%'` → **인덱스 사용 가능** (앞부분이 고정되어야 적용됨)

💡 **주의할 점**\
👉 `LIKE '%keyword%'` 같은 패턴 검색이 필요하면 **Full-Text Index** 또는 **ElasticSearch** 같은 검색 엔진을 고려. Full-Text Index는 데이터베이스 내부에서 지원하는 검색 기능으로, 특정 필드 내에서 단어 기반 검색을 최적화한다. 반면 ElasticSearch는 분산 검색 엔진으로, 대량의 비정형 데이터를 처리하고 더욱 정교한 검색 및 필터링 기능을 제공한다.

---

### 7️⃣ **조인(Join) 시 인덱스 고려**

조인할 때 **ON 조건에 사용되는 컬럼에 인덱스가 없으면 성능 저하** 발생.

```sql
SELECT * FROM orders o
JOIN customers c ON o.customer_id = c.id;
```

위 쿼리에서 `customer_id`, `id` 둘 다 인덱스가 있어야 빠름.

💡 **주의할 점**\
👉 조인 컬럼에 인덱스가 없으면 **Nested Loop Join이 아닌 Hash Join이 발생할 수 있음**\
👉 조인의 조건 컬럼(`FK` 등)에 **인덱스 추가** 고려. 예를 들어, `orders` 테이블의 `customer_id`가 `customers` 테이블의 `id`를 참조하는 외래 키(FK)인 경우, `customer_id`에 인덱스를 추가하면 조인 성능이 향상될 수 있다. 하지만, FK가 자주 업데이트되는 경우 인덱스 유지 비용이 높아질 수 있으므로 필요에 따라 신중하게 추가해야 한다.

---

### 8️⃣ **인덱스 통계 갱신 (ANALYZE, VACUUM, OPTIMIZE)**

데이터베이스는 **인덱스 통계를 기반으로 실행 계획(Execution Plan)을 결정**하는데, 통계가 오래되면 비효율적인 실행 계획이 선택될 수 있음.

💡 **해결 방법**

- MySQL: `ANALYZE TABLE table_name;`
- PostgreSQL: `VACUUM ANALYZE table_name;`
- Oracle: `DBMS_STATS.GATHER_TABLE_STATS('SCHEMA', 'TABLE_NAME');`

---

### 🔥 **결론: 인덱스 사용 시 체크리스트**

✅ **읽기(SELECT) 성능 최적화에 도움이 되는가?**\
✅ **쓰기(INSERT, UPDATE, DELETE) 오버헤드를 감당할 수 있는가?**\
✅ **불필요하거나 중복된 인덱스가 없는가?**\
✅ **카디널리티가 높은 컬럼을 선택했는가?**\
✅ **LIKE 검색에서 와일드카드를 앞에 두지 않았는가?**\
✅ **조인할 컬럼에 인덱스가 있는가?**\
✅ **인덱스 통계를 주기적으로 갱신하는가?**

---

### 📌 **추가 학습 질문**

1. **B-Tree vs. Hash 인덱스 차이점**: B-Tree는 범위 검색과 정렬이 가능하지만, Hash 인덱스는 정확한 키 값 검색에 최적화되어 있음.
2. **클러스터링 인덱스 vs. 보조 인덱스**: 클러스터링 인덱스는 테이블 데이터가 물리적으로 정렬되지만, 보조 인덱스는 별도의 구조를 유지하며 정렬되지 않음.
3. **실행 계획(EXPLAIN, EXPLAIN ANALYZE) 분석**: 실행 계획을 통해 인덱스 사용 여부, 조인 방식, 필터링 효율성을 분석하여 최적화 가능.
4. **NoSQL 인덱스 활용**: MongoDB 등에서는 B-Tree 기반 인덱스를 사용하며, 복합 인덱스와 TTL 인덱스 같은 특수 인덱스도 지원함.


# 심화 질문

## GROUP BY 사용시 인덱스가 걸리는 조건은?

### 1️⃣ `GROUP BY`란?
`GROUP BY`는 **SQL에서 데이터를 특정 컬럼을 기준으로 그룹화하는 기능**이에요.

예를 들어, `orders` 테이블에서 고객(`customer_id`)별로 주문(`amount`)의 총합을 구하고 싶다면 다음과 같이 `GROUP BY`를 사용해요.

```sql
SELECT customer_id, SUM(amount)
FROM orders
GROUP BY customer_id;
```

이렇게 하면 `customer_id`별로 그룹을 묶고, 해당 그룹의 `amount`를 `SUM()`으로 더한 결과가 나와요.

---

### 2️⃣ 인덱스(Index)란?
인덱스는 **데이터 검색을 빠르게 하기 위해 추가하는 자료구조**예요.

- 마치 책의 "목차"처럼 작동해서 특정 데이터를 찾을 때 테이블 전체를 뒤지는 게 아니라 빠르게 접근할 수 있도록 해줘요.
- 인덱스가 있으면 `WHERE`, `ORDER BY`, `JOIN` 같은 쿼리 성능이 개선돼요.

인덱스를 만드는 방법은 다음과 같아요.

```sql
CREATE INDEX idx_customer_id ON orders(customer_id);
```

이렇게 하면 `orders` 테이블에서 `customer_id`를 빠르게 조회할 수 있게 돼요.

---

### 3️⃣ `GROUP BY`와 인덱스의 관계
일반적으로 `GROUP BY`를 사용할 때 **인덱스가 있다면** 성능이 더 빨라질 수 있어요. 하지만 **무조건 인덱스가 적용되는 것은 아니며, 특정 조건을 만족해야 해요.**

#### ✅ `GROUP BY`에서 인덱스가 걸리는 조건
1. **인덱스 컬럼이 `GROUP BY`에서 사용될 것**  
   - `GROUP BY customer_id`를 할 때 `customer_id`에 인덱스가 있어야 함.

2. **`GROUP BY` 대상 컬럼이 정렬된 상태일 것**  
   - MySQL의 경우 `INDEX_SCAN`이나 `INDEX RANGE SCAN`을 활용하려면 인덱스가 "정렬된 상태"여야 함.

3. **일부 DB(MySQL 등)에서는 `ONLY_FULL_GROUP_BY` 모드가 꺼져 있어야 함**  
   - `GROUP BY`할 때 사용하지 않는 컬럼을 `SELECT`할 경우, MySQL의 `ONLY_FULL_GROUP_BY` 설정이 활성화되어 있으면 에러가 날 수 있음.

---

### 4️⃣ 인덱스가 적용되는 예제
다음과 같이 `customer_id`에 인덱스가 있고, `GROUP BY` 대상이 `customer_id` 하나뿐이라면 인덱스가 적용될 수 있어요.

```sql
CREATE INDEX idx_customer_id ON orders(customer_id);

SELECT customer_id, COUNT(*)
FROM orders
GROUP BY customer_id;
```

이 경우, MySQL은 **인덱스를 활용하여 `customer_id`별 그룹을 빠르게 찾아서 카운트**할 수 있어요.

---

### 5️⃣ 인덱스가 적용되지 않는 경우
다음과 같은 경우에는 인덱스가 제대로 활용되지 않을 수도 있어요.

#### ❌ 여러 개의 컬럼을 `GROUP BY` 하는 경우
```sql
SELECT customer_id, order_date, SUM(amount)
FROM orders
GROUP BY customer_id, order_date;
```
- `customer_id, order_date`에 복합 인덱스가 없으면 인덱스가 제대로 활용되지 않음.

#### ❌ `GROUP BY` 컬럼이 함수가 적용된 경우
```sql
SELECT YEAR(order_date), COUNT(*)
FROM orders
GROUP BY YEAR(order_date);
```
- `YEAR(order_date)`는 함수가 적용된 컬럼이라 기존 `order_date` 인덱스를 사용할 수 없음.

#### ❌ `WHERE` 조건이 인덱스를 깨트리는 경우
```sql
SELECT customer_id, COUNT(*)
FROM orders
WHERE amount > 1000
GROUP BY customer_id;
```
- `WHERE amount > 1000` 조건 때문에 전체 테이블을 스캔해야 하는 경우, `customer_id` 인덱스가 덜 활용될 수 있음.

---

### 6️⃣ 인덱스 활용을 위해 `GROUP BY` 최적화하는 방법
1. **`GROUP BY`에 사용될 컬럼에 인덱스를 추가**  
   - `GROUP BY`에서 자주 사용하는 컬럼에 단일 인덱스 또는 복합 인덱스를 생성.

2. **`WHERE` 조건을 잘 활용해서 불필요한 데이터 스캔 방지**  
   - `WHERE`에 인덱스를 활용할 수 있도록 조정.

3. **인덱스 정렬을 활용할 수 있도록 `ORDER BY NULL` 사용 (MySQL의 경우)**  
   - MySQL에서 `GROUP BY` 후 정렬을 피하고 싶다면 `ORDER BY NULL`을 사용하면 불필요한 정렬이 제거됨.

```sql
SELECT customer_id, COUNT(*)
FROM orders
GROUP BY customer_id
ORDER BY NULL;
```

---

### 7️⃣ 결론
- `GROUP BY`는 특정 컬럼을 기준으로 데이터를 그룹화하는 SQL 기능.
- 인덱스는 데이터 검색을 빠르게 해주지만, `GROUP BY`에서 바로 적용되려면 조건이 맞아야 함.
- **인덱스 컬럼을 그대로 사용한 경우** 성능 향상을 기대할 수 있음.
- **함수 적용, 여러 개의 `GROUP BY` 컬럼, `WHERE` 조건이 인덱스를 깨트리는 경우** 인덱스 활용이 어려울 수 있음.
- 최적화를 위해 `GROUP BY` 컬럼에 인덱스를 만들고, 불필요한 정렬을 피해야 함.

이름(`name`), 국가(`country`), 성별(`gender`)이 있는 테이블에서 **어떤 쿼리를 주로 실행하는지에 따라 인덱스를 다르게 설정해야** 해요.

---

## 1️⃣ **기본 테이블 구조**
```sql
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    country VARCHAR(50),
    gender ENUM('M', 'F')
);
```

이제 어떤 인덱스를 추가할지 알아보자!

---

## 2️⃣ **쿼리 패턴에 따른 인덱스 설계**
인덱스는 **자주 실행되는 쿼리에 맞게 최적화**해야 해요. 자주 사용할 쿼리에 따라 다르게 적용할 수 있어요.

---

### ✅ **1. 특정 국가에 속한 유저 목록을 조회하는 경우**
```sql
SELECT * FROM users WHERE country = 'USA';
```
이런 쿼리가 많다면 **`country`에 단일 인덱스**를 추가하면 성능이 향상될 수 있어요.

```sql
CREATE INDEX idx_country ON users(country);
```

**왜 효과적일까?**
- `country`에 대한 검색이 빠르게 수행됨.
- 하지만 `country`의 중복값이 많다면 인덱스 효과가 상대적으로 덜할 수도 있음.

---

### ✅ **2. 특정 국가 + 특정 성별을 조회하는 경우**
```sql
SELECT * FROM users WHERE country = 'USA' AND gender = 'M';
```
이 경우, **`(country, gender)` 복합 인덱스**를 활용하면 성능이 더 좋아질 수 있어요.

```sql
CREATE INDEX idx_country_gender ON users(country, gender);
```

**왜 이게 좋을까?**
- MySQL이나 PostgreSQL에서는 **왼쪽부터 정렬된 방식**으로 인덱스를 사용함.
- 따라서 `WHERE country = 'USA'`만 검색해도 이 인덱스를 활용할 수 있음.
- 그리고 추가적으로 `gender`도 함께 필터링하므로 효율적임.

> 🎯 **복합 인덱스에서는 컬럼 순서가 중요함!**  
> **조회 쿼리에서 가장 자주 필터링하는 컬럼을 먼저 배치**하는 것이 일반적.

---

### ✅ **3. 특정 국가 + 특정 성별 + 이름 검색까지 포함하는 경우**
```sql
SELECT * FROM users WHERE country = 'USA' AND gender = 'M' AND name LIKE 'A%';
```
이런 패턴이 많다면, **복합 인덱스 (`country, gender, name`)**를 고려할 수 있어요.

```sql
CREATE INDEX idx_country_gender_name ON users(country, gender, name);
```

**이렇게 하면?**
- `WHERE country = 'USA' AND gender = 'M'`까지는 빠르게 인덱스를 활용할 수 있음.
- 그러나 `name LIKE 'A%'`는 **범위 검색**이므로, 일부 DB에서는 인덱스 사용이 어려울 수도 있음.

> 🔹 **주의할 점**  
> - `LIKE '%A'` 또는 `LIKE '%A%'`는 **인덱스를 거의 활용하지 못함.**  
> - `LIKE 'A%'` 형태일 경우 인덱스를 활용할 수도 있음.

---

### ✅ **4. 이름 검색이 가장 중요하다면?**
```sql
SELECT * FROM users WHERE name = 'John Doe';
```
이런 단순한 검색을 자주 한다면 **이름(name)에 단일 인덱스**를 추가하는 게 더 유리해요.

```sql
CREATE INDEX idx_name ON users(name);
```
- `name`이 중복이 적다면 빠른 검색 가능.
- 그러나 단순한 이름 검색이 아니라 **국가나 성별 필터도 함께 적용**한다면, 복합 인덱스(`country, gender, name`)가 더 나을 수도 있음.

---

## 3️⃣ **인덱스 설계 정리**
| 주요 쿼리 패턴 | 추천 인덱스 |
|---------------|------------|
| 특정 국가의 유저 조회 | `CREATE INDEX idx_country ON users(country);` |
| 특정 국가 + 특정 성별 조회 | `CREATE INDEX idx_country_gender ON users(country, gender);` |
| 특정 국가 + 특정 성별 + 이름 검색 (`LIKE 'A%'`) | `CREATE INDEX idx_country_gender_name ON users(country, gender, name);` |
| 이름만으로 검색 (`name = 'John Doe'`) | `CREATE INDEX idx_name ON users(name);` |

---

## 4️⃣ **인덱스 사용 시 주의할 점**
1. **너무 많은 인덱스를 만들면 오히려 성능이 떨어질 수 있음**  
   - 인덱스가 많으면 **데이터 삽입/수정/삭제 시 오버헤드**가 발생함.
   - 필요한 최소한의 인덱스만 설정하는 것이 중요.

2. **복합 인덱스는 "왼쪽부터" 적용됨**
   - 예를 들어 `(country, gender, name)` 인덱스가 있다면:
     - `WHERE country = 'USA' AND gender = 'M'` → ✅ 인덱스 사용 가능
     - `WHERE gender = 'M'` → ❌ `gender`만 사용하면 인덱스 적용 안 됨

3. **`LIKE '%A%'` 패턴은 인덱스를 잘 활용하지 못함**
   - `LIKE 'A%'`는 인덱스를 사용할 가능성이 있음.
   - 하지만 `%A%` 형태라면 **인덱스가 무용지물**이 될 수 있음.

---

## 5️⃣ **결론**
- 가장 자주 실행하는 쿼리에 맞춰 인덱스를 설계해야 함.
- 단일 조건이면 **단일 인덱스**, 여러 개의 조건이 있다면 **복합 인덱스**가 유리할 수 있음.
- 복합 인덱스를 만들 때 **컬럼 순서**를 잘 고려해야 함 (`WHERE`에서 가장 먼저 사용되는 컬럼부터 배치).
