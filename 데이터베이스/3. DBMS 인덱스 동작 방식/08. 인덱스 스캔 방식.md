## 📌 **인덱스 스캔 방식의 종류와 특징**

### 1️⃣ **Index Range Scan (인덱스 범위 스캔)**

- **특징**: B-트리 인덱스의 가장 일반적이고 정상적인 액세스 방식으로, 인덱스 루트에서 리프 블록까지 수직적 탐색 후, 필요한 범위만큼 수평적으로 탐색합니다.

- **사용 조건**: 인덱스의 선두 컬럼이 WHERE 절에 포함되고, 해당 컬럼에 대한 범위 조건(`=`, `>`, `<`, `BETWEEN`, `LIKE 'abc%'` 등)이 있을 때 사용됩니다.

- **예제**:
  ```sql
  SELECT * FROM employees WHERE last_name LIKE 'Smith%';
  ```

### 2️⃣ **Index Unique Scan (인덱스 유니크 스캔)**

- **특징**: 유니크 인덱스에서 단일 행을 정확히 찾아낼 때 사용되며, 수직적 탐색으로만 데이터를 찾습니다.

- **사용 조건**: 유니크 인덱스가 존재하고, 해당 인덱스 컬럼에 대한 `=` 조건이 주어졌을 때 사용됩니다.

- **예제**:
  ```sql
  SELECT * FROM employees WHERE employee_id = 100;
  ```

### 3️⃣ **Index Full Scan (인덱스 풀 스캔)**

- **특징**: 인덱스의 루트부터 리프 블록까지 수직적 탐색 없이, 리프 블록의 처음부터 끝까지 수평적으로 모든 인덱스 엔트리를 스캔합니다.

- **사용 조건**: 인덱스의 선두 컬럼이 WHERE 절에 없거나, 인덱스를 완전히 스캔하는 것이 효율적일 때 사용됩니다.

- **예제**:
  ```sql
  SELECT * FROM employees ORDER BY last_name;
  ```

전체 조회를 한다면 불필요하게 탐색 알고리즘을 사용할 필요가 없으니, 리프 노드를 처음부터 끝까지 "순차적으로" 읽는 전략이야. (논리적 순서 유지) 단일 블록 I/O 검색 방식이지.(한 번에 한 블록씩 읽음) 정렬된 순서로 순차적으로 데이터를 읽기 때문에 `ORDER BY` 최적화에 사용돼.  

하지만 인덱스 테이블 내 모든 데이터를 읽기 때문에 비교적 느릴 수 있다는 점에 주의해야 해.

### 4️⃣ **Index Skip Scan (인덱스 스킵 스캔)**

- **특징**: 복합 인덱스의 선두 컬럼이 WHERE 절에 없더라도, 후속 컬럼을 이용하여 인덱스를 스캔하는 방식입니다.

- **사용 조건**: 복합 인덱스의 첫 번째 컬럼이 조건절에 없고, 두 번째 이후 컬럼이 조건절에 있을 때 사용됩니다.

- **예제**:
  ```sql
  CREATE INDEX idx_users ON users (gender, age);

  SELECT * FROM users WHERE age = 30;
  ```

B-트리 인덱스는 선두 컬럼을 기준으로 정렬된 트리 구조를 가지고 있어.
즉, 검색할 때는 항상 선두 컬럼부터 검색을 시작해야 효율적이야.
만약 선두 컬럼을 건너뛰고 후속 컬럼만 검색하면, 원래는 인덱스를 사용할 수 없지만, Index Skip Scan이 이를 가능하게 해줘.

Index Skip Scan은 선두 컬럼을 건너뛰고 후속 컬럼을 검색할 때 다음과 같이 동작해: 
1. B-트리의 모든 gender 값에 대해 반복적으로 age = 30을 검색
2. gender = 'M' 인 부분에서 age = 30을 찾음
3. gender = 'F' 인 부분에서도 age = 30을 찾음
4. 결과를 합쳐서 반환

즉, 선두 컬럼이 없는 경우에도 각 파티션(예: gender별로) 나누어 스캔하는 방식으로 후속 컬럼 검색을 가능하게 하는 거야.

Index Skip Scan이 항상 좋은 건 아니야!
- 선두 컬럼의 중복도가 높을수록(고유 값의 종류가 다양할수록) Index Skip Scan이 효과적
- 선두 컬럼의 값이 너무 적으면(예: gender가 M, F뿐이면) 여러 번의 인덱스 조회가 필요해져서 오히려 성능이 나빠질 수 있음(Table Full Scan과 다를 바가 없어서 인덱스를 따로 만들어 준 의미가 없다는 말임.)

### 5️⃣ **Index Fast Full Scan (인덱스 패스트 풀 스캔)**

- **특징**: 인덱스의 논리적 구조를 무시하고, 물리적으로 디스크에 저장된 순서대로 인덱스 리프 블록을 멀티블록 I/O 방식으로 스캔합니다. **테이블을 직접 읽는 Full Table Scan을 피하면서도, 인덱스 전체를 빠르게 읽어야 할 때 사용되는 방식입니다.**

- **사용 조건**: 쿼리에 필요한 모든 컬럼이 인덱스에 포함되어 있고, 테이블 전체를 읽는 것보다 인덱스를 전체 스캔하는 것이 효율적일 때 사용됩니다.

- **예제**:
  ```sql
  SELECT COUNT(*) FROM employees;
  ```

보통 B-트리 인덱스를 탐색할 때는 루트 → 브랜치 → 리프 노드 순으로 이동하는 계층적 탐색 방식을 사용해. 하지만 Index Fast Full Scan은 이 과정을 생략하고 바로 리프 노드 전체를 읽는 방식이야.

💡 즉, "디스크 순서대로 읽는다"는 의미는, 논리적 트리 구조를 무시하고 물리적으로 저장된 블록을 직접 읽는다는 뜻!

이때 멀티블록 I/O 방식(Multiple Block Read)을 사용하여, 디스크의 데이터를 물리적으로 저장된 순서대로 빠르게 읽어.
즉, 병렬 처리가 가능하며, 전체 인덱스를 빠르게 읽을 수 있도록 최적화된 방식이야.(순차적인 조회 방식이 아님!)

하지만 `ORDER BY` 사용 시 인덱스가 완벽하게 정렬된 상태가 아닌 경우, 추가적인 정렬 비용이 발생하여 오히려 성능이 나빠질 수 있으니 주의해서 사용해야 한다.