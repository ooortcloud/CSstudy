# 📌 **클러스터링 인덱스 vs. 비클러스터링 인덱스**
데이터베이스에서 인덱스를 사용할 때 **클러스터링 인덱스(Clustered Index)** 와 **비클러스터링 인덱스(Non-Clustered Index)** 개념이 자주 등장해!  
이 개념을 잘 이해하면 **데이터 검색 속도를 최적화하고 성능을 높이는 방법**을 알 수 있어.  

## 🏗 **클러스터링 인덱스(Clustered Index)란?**
**데이터 자체가 정렬된 상태로 저장되는 인덱스**  
- 인덱스의 순서와 **실제 데이터의 물리적 저장 순서가 동일**함  
- 테이블 당 **한 개만 존재**할 수 있음 (물리적으로 정렬되기 때문)  
- 기본 키(Primary Key)가 자동으로 클러스터링 인덱스가 되는 경우가 많음  

### ✅ **예제**
```sql
CREATE TABLE users (
    id INT PRIMARY KEY,  -- 기본 키가 자동으로 클러스터링 인덱스가 됨
    name VARCHAR(50),
    email VARCHAR(100)
);
```
💡 `id` 컬럼이 클러스터링 인덱스라면, `id` 기준으로 테이블의 **실제 데이터가 정렬**됨.  
즉, `id = 5`를 검색하면, **데이터가 정렬된 상태**이므로 **이진 탐색**이 가능해 검색이 빠름!  


## 🔍 **비클러스터링 인덱스(Non-Clustered Index)란?**
**데이터 자체가 정렬되지 않고, 인덱스만 별도로 저장되는 방식**  
- 인덱스와 실제 데이터가 **따로 관리됨**  
- 하나의 테이블에 **여러 개의 비클러스터링 인덱스를 만들 수 있음**  
- 인덱스를 찾고 나서 **실제 데이터를 다시 한 번 조회해야 하는 경우가 있음 (추가적인 I/O 발생)**  

### ✅ **예제**
```sql
CREATE INDEX idx_users_name ON users(name);
```
💡 위와 같이 `name` 컬럼에 비클러스터링 인덱스를 추가하면?  
- `name` 기준으로 정렬된 **인덱스 테이블**이 생성됨  
- 하지만 **실제 데이터는 원래 저장된 순서 그대로 유지됨**
- 따라서 **name → 인덱스 테이블 검색 → 실제 데이터 테이블에서 조회** 2단계 과정이 필요  

## ⚖ **클러스터링 vs. 비클러스터링 인덱스 비교**
| 비교 항목 | 클러스터링 인덱스 | 비클러스터링 인덱스 |
|-----------|------------------|-------------------|
| **데이터 저장 방식** | 데이터 자체가 정렬됨 | 데이터는 정렬되지 않고, 인덱스만 정렬됨 |
| **테이블당 개수** | 1개만 가능 (물리적 정렬) | 여러 개 가능 |
| **검색 속도** | 빠름 (정렬된 상태) | 다소 느림 (추가 조회 필요) |
| **추가적인 저장 공간** | 필요 없음 | 별도의 인덱스 저장 공간 필요 |
| **삽입/삭제 성능** | 느릴 수 있음 (재정렬 필요) | 빠름 |

---

## 🚀 **언제 사용하면 좋을까?**
✅ **클러스터링 인덱스 추천 상황**  
- `PRIMARY KEY`나 `UNIQUE` 컬럼이 자주 검색될 때  
- **범위 검색 (`BETWEEN`, `<`, `>`)이 많은 경우**  
- **ORDER BY, GROUP BY** 성능을 높이고 싶을 때  

✅ **비클러스터링 인덱스 추천 상황**  
- **WHERE 조건이 다양한 컬럼에서 자주 사용될 때**  
- **JOIN, LIKE 검색이 많을 때**  
- **검색 대상이 많지 않고 특정 값을 빠르게 찾고 싶을 때** (`SELECT * FROM users WHERE name = 'Kim';`)  

## 📌 **정리**
- 클러스터링 인덱스: **데이터 자체를 정렬하여 저장하는 인덱스**  
- 비클러스터링 인덱스: **데이터와 별도로 인덱스를 관리하는 방식**  
- **클러스터링은 빠른 검색 & 정렬에 유리하지만, 삽입/삭제 성능이 저하될 수 있음**  
- **비클러스터링은 범용적인 검색 성능 향상에 유리하고 여러 개를 만들 수 있음**  

# 🎯 **비클러스터링 인덱스가 필요한 이유**

비클러스터링 인덱스의 장점이 잘 와닿지 않는다면, **왜 굳이 비클러스터링 인덱스를 사용할까?** 하는 의문이 들 거야. 사실 **클러스터링 인덱스만으로는 해결할 수 없는 문제들이 있어서 비클러스터링 인덱스가 필요**해!  

### 🏗 1. **한 개 이상의 인덱스를 사용할 수 있음 (다양한 검색 최적화)**
클러스터링 인덱스는 **테이블당 1개만 가능**하지만, 비클러스터링 인덱스는 **여러 개 만들 수 있어**.  

### ✅ **예제**
```sql
CREATE TABLE users (
    id INT PRIMARY KEY, -- 클러스터링 인덱스
    name VARCHAR(50),
    email VARCHAR(100)
);
CREATE INDEX idx_users_name ON users(name); -- 비클러스터링 인덱스
CREATE INDEX idx_users_email ON users(email); -- 또 다른 비클러스터링 인덱스
```
💡 만약 `name`과 `email`을 자주 검색해야 한다면?  
👉 **비클러스터링 인덱스를 추가하면 빠르게 검색할 수 있음**.  
👉 클러스터링 인덱스만 있다면? **name으로 검색할 때도 id 기반 검색을 해야 하므로 비효율적**.

---

### 🔍 2. **클러스터링 인덱스만으로는 다양한 검색을 최적화할 수 없음**
- 클러스터링 인덱스는 **기본적으로 정렬된 컬럼(예: PRIMARY KEY)에만 적용**되므로,  
  `id`가 아닌 다른 컬럼으로 검색할 때는 속도가 느려질 수 있음.
- 예를 들어, `name`으로 검색하려면 비클러스터링 인덱스가 없으면 **전체 테이블을 조회**해야 함.

#### ✅ **비클러스터링 인덱스가 없을 때 검색 과정**
```sql
SELECT * FROM users WHERE name = 'Alice';
```
1️⃣ `users` 테이블의 모든 데이터를 조회 (Full Table Scan)  
2️⃣ `name = 'Alice'`인 데이터를 찾음  

**❌ 비효율적! 느림!** 😫

#### ✅ **비클러스터링 인덱스가 있을 때 검색 과정**
```sql
SELECT * FROM users WHERE name = 'Alice';
```
1️⃣ `idx_users_name` (비클러스터링 인덱스)에서 `Alice`의 `id` 찾기  
2️⃣ 해당 `id`를 이용해 `users` 테이블에서 데이터 조회  

**✔ 훨씬 빠름!** 🚀

---

### 🚀 3. **테이블이 커질수록 비클러스터링 인덱스의 효과가 극대화됨**
데이터가 많아질수록 **Full Table Scan**(테이블 전체 조회)이 엄청 비효율적이야.  
- 비클러스터링 인덱스가 있으면 필요한 데이터만 조회할 수 있어서 속도가 **훨씬 빨라짐**.  

#### 📌 **예제: 1천만 개의 데이터가 있는 테이블**
```sql
SELECT * FROM users WHERE email = 'bob@example.com';
```
- 비클러스터링 인덱스 없이 검색하면?  
  👉 **1천만 개의 데이터를 하나하나 조회해야 함** 😱
- 비클러스터링 인덱스를 `email`에 추가하면?  
  👉 **빠르게 특정 `email` 값을 찾고 해당 데이터만 조회** 😎  

---

### 🎯 4. **특정한 컬럼 조합에 대한 검색을 최적화할 수 있음 (다중 인덱스 활용)**
비클러스터링 인덱스는 **복합 인덱스(Composite Index)** 도 만들 수 있어.  
즉, 여러 개의 컬럼을 조합해서 인덱스를 만들면 **여러 조건을 동시에 만족하는 검색을 최적화할 수 있음**.

#### ✅ **예제: `name`과 `email`을 동시에 검색할 경우**
```sql
CREATE INDEX idx_users_name_email ON users(name, email);
```
```sql
SELECT * FROM users WHERE name = 'Alice' AND email = 'alice@example.com';
```
👉 **인덱스에서 한 번에 name과 email을 조회 가능!**  
👉 만약 `name`과 `email`에 개별적으로 비클러스터링 인덱스를 만들었다면, 각각 조회해야 하므로 느려질 수도 있음.  

---

### ⚖ **정리: 비클러스터링 인덱스의 장점**
| 장점 | 설명 |
|------|------|
| ✅ 여러 개 생성 가능 | 테이블당 한 개만 존재하는 클러스터링 인덱스와 달리, 다양한 컬럼에 인덱스를 추가할 수 있음 |
| ✅ 다양한 컬럼 검색 최적화 | `name`, `email` 같은 특정 컬럼에 대해 빠른 검색을 제공 |
| ✅ 테이블이 커질수록 성능 향상 | Full Table Scan을 방지하고 특정 데이터를 빠르게 찾을 수 있음 |
| ✅ 복합 인덱스로 다중 조건 최적화 | 여러 개의 컬럼을 하나의 인덱스로 만들 수 있어 다중 조건 검색 속도 개선 |

---

## 📌 **결론**
비클러스터링 인덱스는 **데이터베이스 검색 성능을 향상시키기 위해 필수적인 개념**이야.  
- 테이블이 커질수록 **Full Table Scan을 줄이고 검색 속도를 높이는 데 중요**  
- 특정 컬럼을 자주 조회하면 **비클러스터링 인덱스를 추가하여 검색 성능을 개선**  
- 하나의 클러스터링 인덱스만으로는 **모든 검색을 최적화할 수 없기 때문에 보완적으로 사용**  
