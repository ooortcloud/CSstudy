## B-tree 인덱스

### **1. B-Tree란?**

B-Tree는 **Balanced Tree**의 약자로, **이진 검색 트리**(Binary Search Tree)의 확장판이라고 이해하시면 됩니다. B-Tree는 데이터베이스 인덱싱에서 매우 중요한 자료구조 중 하나로, 특히 대용량 데이터 처리에 적합합니다. 주요 특징은 다음과 같습니다:

1. **균형 잡힌 트리 구조**:
   - 모든 리프 노드(Leaf Node, 가장 말단 노드)는 동일한 깊이에 있습니다. 이는 트리가 항상 균형 상태를 유지한다는 것을 의미합니다.
   
2. **다개분 노드 구조**:
   - B-Tree는 이진 트리와 달리, **한 노드가 여러 개의 키(Key)와 자식 노드**를 가질 수 있습니다. 이를 통해 트리의 높이를 줄이고 검색 효율을 높입니다.
   
3. **정렬된 키 저장**:
   - 각 노드에 저장된 키들은 **오름차순으로 정렬**되어 있으며, 특정 키를 기준으로 자식 노드가 구분됩니다.

---

### **2. B-Tree의 구성 요소**

B-Tree는 다음과 같은 구성 요소를 가지고 있습니다:

1. **노드(Node)**:
   - 하나의 노드는 여러 개의 키(Key)와 자식 노드(Child Node)를 가질 수 있습니다.
   - 한 노드가 가지는 최소 자식 노드 수를 `t`라고 할 때:
     - 최소 키 개수: `t-1`
     - 최대 키 개수: `2t-1`
     - 자식 노드의 개수: 키의 개수 + 1 (최대 `2t`개)

2. **트리의 차수(Degree)**:
   - 차수 `t`는 한 노드가 가질 수 있는 **최소 자식 노드 수**를 나타냅니다.
   - 예를 들어, `t=3`이면, 각 노드는 최소 2개에서 최대 5개의 자식 노드를 가질 수 있습니다.

3. **루트 노드(Root Node)**:
   - 루트 노드는 최소 하나의 키를 가져야 합니다.
   - 리프 노드와 마찬가지로, 루트 노드도 항상 같은 깊이에 있어야 합니다.

---

### **3. B-Tree의 동작**

B-Tree에서 가장 중요한 연산은 삽입, 삭제, 검색입니다. 각각의 동작 방식을 간략히 설명드리겠습니다:

#### **1) 검색(Search)**
- 검색 과정은 이진 검색 트리와 비슷합니다.
  1. 현재 노드의 키 배열을 순회하여 목표 키를 찾습니다.
  2. 키가 없다면, 해당 키의 범위에 맞는 자식 노드로 이동합니다.
  3. 리프 노드에 도달하거나 키를 찾을 때까지 반복합니다.
- 트리의 높이가 낮기 때문에 검색 시간이 효율적입니다. (시간 복잡도: `O(log N)`)

#### **2) 삽입(Insertion)**
- 새로운 키를 삽입할 때, 리프 노드에 저장합니다.
- 노드가 키 개수 제한(`2t-1`)을 초과하면 **분할(Split)**이 발생합니다:
  1. 초과된 노드의 중앙 키를 상위 노드로 올립니다.
  2. 나머지 키들은 두 개의 자식 노드로 분리됩니다.
  3. 이 과정은 루트 노드까지 전파될 수 있습니다.
- 삽입 작업 후에도 트리는 항상 균형 상태를 유지합니다.

#### **3) 삭제(Deletion)**
- 키를 삭제할 때, 다음 세 가지 경우를 고려합니다:
  1. **리프 노드에서 키 삭제**: 바로 삭제하면 됩니다.
  2. **내부 노드에서 키 삭제**:
     - 왼쪽 자식의 최대 키 또는 오른쪽 자식의 최소 키로 대체 후 삭제합니다.
  3. **키 삭제 후 언더플로우 발생**:
     - 언더플로우(키 개수가 `t-1` 미만)가 발생하면, **형제 노드에서 키를 빌리거나 병합(Merge)**을 수행하여 균형을 유지합니다.

---

### **4. B-Tree의 장점**

B-Tree는 다음과 같은 이유로 데이터베이스 인덱스에서 자주 사용됩니다:

1. **효율적인 디스크 I/O**:
   - 데이터베이스는 대용량 데이터를 디스크에 저장합니다. B-Tree는 한 노드에 여러 키를 저장함으로써 디스크 읽기/쓰기 횟수를 최소화합니다.

2. **높이 제한**:
   - B-Tree는 키가 많아져도 트리의 높이가 낮게 유지되므로, 검색과 삽입/삭제 연산이 항상 빠릅니다.

3. **동적 균형 유지**:
   - 삽입과 삭제 후에도 트리가 자동으로 균형을 유지하기 때문에, 성능이 일관됩니다.

---

### **5. 데이터베이스에서 B-Tree 인덱스 활용 예시**

- 데이터베이스에서 B-Tree 인덱스는 **범위 검색**과 같은 연산에서 주로 사용됩니다.
- 예를 들어, `SELECT * FROM table WHERE age BETWEEN 20 AND 30;`와 같은 쿼리에서 B-Tree 인덱스는 범위 내 키를 빠르게 찾아냅니다.


## B+tree 인덱스

### **1. B+트리란?**

B+트리(B+ Tree)는 데이터베이스에서 B-트리(B-Tree)의 변형된 자료구조로, 특히 **데이터 인덱싱**과 **범위 검색**에서 매우 효율적입니다. B-트리와 기본적인 구조는 비슷하지만, 데이터베이스 인덱스에 더 적합하도록 설계되었습니다. B+트리는 B-트리의 모든 특징을 포함하면서도 추가적인 구조적 이점을 제공합니다. 주된 특징은 다음과 같습니다:

1. **리프 노드에 모든 키를 저장**:
   - B+트리는 **모든 키와 데이터를 리프 노드에만 저장**합니다. 내부 노드는 **경로 탐색에 필요한 키만 저장**합니다.

2. **리프 노드 간 연결(Linked List 구조)**:
   - 모든 리프 노드가 **연결 리스트 형태로 연결**되어 있어, 순차 접근이 매우 효율적입니다.

3. **높은 디스크 접근 효율성**:
   - 리프 노드에 데이터를 집중시켜 디스크 I/O를 줄이고, 검색 및 범위 쿼리 성능을 극대화합니다.

---

### **2. B+트리의 구조**

B+트리의 구조는 다음과 같은 계층으로 이루어져 있습니다:

#### **1) 내부 노드(Internal Node)**:
- 키만 저장하며, 데이터를 저장하지 않습니다.
- 자식 노드로 향하는 경로를 결정하는 역할을 합니다.
- 키의 개수는 최대 `2t-1`, 자식 노드의 개수는 최대 `2t`입니다. (t는 트리의 차수)

#### **2) 리프 노드(Leaf Node)**:
- 모든 키와 데이터가 저장되는 노드입니다.
- 키들은 오름차순으로 정렬되어 있으며, 각 노드는 **다음 리프 노드와 연결**됩니다.
- 리프 노드 간 연결은 범위 쿼리와 순차 접근에서 효율성을 극대화합니다.

---

### **3. B+트리의 동작**

B+트리에서의 주요 연산(검색, 삽입, 삭제)은 다음과 같은 방식으로 동작합니다:

#### **1) 검색(Search)**:
1. 루트 노드에서 시작하여 탐색할 키의 범위를 확인합니다.
2. 내부 노드에서 키를 비교하며 하위 노드로 이동합니다.
3. 리프 노드에 도달하면, 키를 정확히 찾거나 범위에 해당하는 데이터를 검색합니다.
4. 리프 노드가 연결 리스트로 연결되어 있으므로, **범위 검색** 시 탐색이 매우 효율적입니다.

   **시간 복잡도**: `O(log N)` (트리의 높이에 비례)

#### **2) 삽입(Insertion)**:
1. 새로운 키와 데이터를 리프 노드에 삽입합니다.
2. 삽입 후 리프 노드가 키 개수 제한(`2t-1`)을 초과하면, 노드를 분할(Split)합니다:
   - 중앙 키를 상위 노드로 올리고, 나머지 키는 두 개의 새로운 리프 노드에 나눠 저장합니다.
3. 상위 노드에서도 키 개수 초과가 발생하면, 동일한 과정을 루트까지 반복합니다.

   **시간 복잡도**: `O(log N)` (트리의 높이에 비례)

#### **3) 삭제(Deletion)**:
1. 리프 노드에서 키를 삭제합니다.
2. 삭제 후 키 개수가 최소치(`t-1`)보다 적어지면, 형제 노드와 병합(Merge)하거나 형제 노드에서 키를 빌립니다(Rebalance).
3. 병합이나 재분배 과정은 상위 노드로 전파될 수 있습니다.

   **시간 복잡도**: `O(log N)`

---

### **4. B-트리와 B+트리의 차이점**

| **특징**              | **B-트리**                                  | **B+트리**                                      |
|-----------------------|---------------------------------------------|------------------------------------------------|
| **키 저장 위치**       | 키와 데이터가 내부 노드와 리프 노드에 모두 저장됨 | 모든 데이터가 리프 노드에만 저장됨         |
| **내부 노드**          | 키와 데이터를 함께 저장                     | 경로 탐색용 키만 저장                           |
| **순차 접근**          | 비효율적                                    | 리프 노드들이 연결 리스트로 연결되어 효율적      |
| **범위 쿼리 성능**      | 범위 검색이 상대적으로 비효율적              | 리프 노드 연결 리스트를 통해 범위 검색이 빠름    |
| **공간 효율성**        | 덜 효율적                                   | 리프 노드에만 데이터를 저장하므로 더 효율적      |

---

### **5. B+트리의 장점**

B+트리는 데이터베이스 인덱스에 최적화된 이유로 다음과 같은 장점이 있습니다:

1. **빠른 범위 검색**:
   - 리프 노드 간 연결 리스트를 통해 연속된 키를 빠르게 접근할 수 있어 범위 쿼리(Range Query)에 매우 효율적입니다.

2. **높은 디스크 I/O 효율성**:
   - 내부 노드는 메모리 내에서 탐색에만 사용되고, 실제 데이터는 리프 노드에 저장되므로 디스크 접근 횟수가 줄어듭니다.

3. **일관된 트리 깊이**:
   - 모든 데이터가 리프 노드에 있으므로, 데이터 접근 시 항상 동일한 깊이의 트리 탐색을 수행합니다.

4. **확장성**:
   - 삽입, 삭제 연산 후에도 트리의 균형을 유지하기 때문에 대용량 데이터 처리에 적합합니다.

---

### **6. 데이터베이스에서 B+트리의 활용**

B+트리는 데이터베이스의 **클러스터형 인덱스(Clustered Index)** 와 **비클러스터형 인덱스(Non-clustered Index)** 를 구현하는 데 사용됩니다.

#### **1) 클러스터형 인덱스**:
- 리프 노드에 실제 데이터 레코드가 저장됩니다.
- 예: `PRIMARY KEY`로 설정된 열에 대해 자동 생성되는 인덱스.

#### **2) 비클러스터형 인덱스**:
- 리프 노드에 데이터의 참조 값(예: Row ID)이 저장됩니다.
- 예: 일반 `INDEX`로 설정된 열에 대해 생성되는 인덱스.

#### **3) 범위 검색에 최적**:
- `WHERE salary BETWEEN 5000 AND 10000;` 같은 범위 쿼리에서 B+트리는 리프 노드 간 연결 리스트를 활용하여 데이터를 빠르게 검색합니다.

#### **4) 정렬된 데이터 접근**:
- 리프 노드에 키가 정렬된 상태로 저장되므로, 정렬된 결과를 쉽게 얻을 수 있습니다.

---

### **7. 요약**

B+트리는 데이터베이스에서 범위 쿼리와 대량 데이터 처리에 최적화된 자료구조입니다. 특히 **범위 검색**과 **순차 접근**에서 매우 효율적이며, 디스크 I/O를 최소화하여 빠른 성능을 제공합니다. B-트리보다 더 많은 데이터를 처리할 수 있고, 데이터베이스에서 자주 사용되는 쿼리 유형에 잘 맞는 구조입니다.