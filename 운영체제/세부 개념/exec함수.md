**`exec()` 함수**는 유닉스 계열 운영체제에서 사용되는 시스템 호출로, 프로세스가 실행 중인 프로그램을 완전히 새로운 프로그램으로 대체하는 데 사용됩니다. `exec()` 함수가 호출되면, 호출한 프로세스의 메모리 공간, 코드, 데이터, 스택, 힙 등이 전부 교체되고, 새로운 프로그램이 기존 프로세스의 PID를 유지한 채 실행됩니다.

`exec()` 함수 계열은 여러 가지 변형이 있으며, 그 이름에 따라 세부적인 사용 방식과 인자 전달 방법이 다를 수 있습니다.

### 1. `exec()` 함수의 주요 특징

- **프로세스 대체**: `exec()` 함수는 현재 실행 중인 프로세스를 새로운 프로그램으로 대체합니다. 이때 기존의 메모리 공간은 완전히 덮어씌워집니다.
- **PID 유지**: 새로운 프로그램이 실행되더라도 기존 프로세스의 PID는 유지됩니다. 따라서 새로운 프로그램은 기존 프로세스처럼 동작하지만, 완전히 다른 프로그램으로 바뀐 것입니다.
- **fork()와의 조합**: 일반적으로 `fork()`와 함께 사용됩니다. `fork()`는 부모 프로세스에서 자식 프로세스를 생성한 후, 자식 프로세스가 `exec()`를 호출하여 새로운 프로그램을 실행하는 방식입니다.
- **돌아오지 않음**: `exec()` 함수가 성공적으로 호출되면, 이전에 실행되던 프로그램의 제어 흐름으로 돌아오지 않습니다. 새로운 프로그램이 그 자리에서 실행되기 때문에, `exec()` 호출 이후의 코드는 실행되지 않습니다.

### 2. `exec()` 계열 함수들

`exec()` 계열 함수들은 동일한 목적을 가지고 있으나, 인자를 전달하는 방식과 환경 변수를 처리하는 방식에서 차이가 있습니다. 대표적인 함수들은 다음과 같습니다:

- **`execl()`**: 가변 인수로 명령어와 인자를 전달.
- **`execv()`**: 배열로 명령어와 인자를 전달.
- **`execle()`**: 가변 인수로 명령어와 인자를 전달하며, 명시적으로 환경 변수를 설정.
- **`execve()`**: 배열로 명령어와 인자를 전달하며, 명시적으로 환경 변수를 설정.
- **`execlp()`**: 가변 인수로 명령어와 인자를 전달하며, 환경 변수는 기존 것을 사용하고, PATH 환경 변수로 경로를 찾음.
- **`execvp()`**: 배열로 명령어와 인자를 전달하며, 환경 변수는 기존 것을 사용하고, PATH 환경 변수로 경로를 찾음.

각각의 함수 이름에서 **'l'**은 **리스트(list)** 방식으로 인자를 하나씩 나열하는 것을 의미하고, **'v'**는 **벡터(vector)** 방식으로 인자들을 배열 형태로 전달하는 것을 의미합니다. **'p'**는 경로 탐색을 허용하며, **'e'**는 명시적으로 환경 변수를 전달할 수 있다는 의미입니다.

### 3. `exec()` 함수 사용 예시

#### 3.1. `execl()` 예시:
`execl()`은 명령어와 그 인자를 리스트로 전달하는 방식입니다.

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("Before exec()\n");
    execl("/bin/ls", "ls", "-l", (char *)0);
    printf("This will not be printed if exec() is successful.\n");
    return 0;
}
```

- `/bin/ls` 명령을 실행하여 디렉토리 목록을 출력합니다.
- `execl()` 호출 이후 프로그램은 새로운 프로그램(여기서는 `ls`)으로 대체되며, 성공 시 이후의 코드가 실행되지 않습니다.

#### 3.2. `execvp()` 예시:
`execvp()`는 배열로 명령어와 인자를 전달하며, PATH 환경 변수를 사용해 명령어의 경로를 자동으로 탐색합니다.

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *args[] = {"ls", "-l", NULL};
    printf("Before execvp()\n");
    execvp("ls", args);
    printf("This will not be printed if execvp() is successful.\n");
    return 0;
}
```

- `execvp()`는 PATH 환경 변수에서 `ls` 명령을 찾아 실행합니다.
- 마찬가지로 `execvp()`가 성공하면 이후 코드는 실행되지 않습니다.

### 4. `exec()` 함수의 동작 원리

`exec()` 계열 함수는 **현재 프로세스를 새로운 프로그램으로 덮어씌우는 작업**을 수행합니다. 이를 위해 운영체제는 다음 단계를 따릅니다:

1. **현재 프로세스의 메모리 초기화**: 현재 프로세스의 메모리 공간을 전부 제거합니다. 기존의 코드, 데이터, 힙, 스택 등이 모두 초기화됩니다.
2. **새로운 프로그램 로드**: 지정된 새로운 프로그램을 현재 프로세스의 메모리 공간에 로드합니다.
3. **새로운 프로그램 실행**: 새로운 프로그램의 첫 번째 명령어를 실행합니다. 이때, 기존의 PID는 그대로 유지되며, 프로세스는 완전히 다른 프로그램으로 전환됩니다.

### 5. `exec()` 함수의 특징 및 주의점

- **제어 흐름 복귀 불가**: `exec()` 호출 후에는 새로운 프로그램이 실행되므로, 호출한 함수로 다시 돌아올 수 없습니다.
- **자식 프로세스에서 주로 사용**: `fork()`와 함께 자식 프로세스를 생성하고, 자식 프로세스에서 `exec()`를 호출하여 새로운 프로그램을 실행하는 방식이 일반적입니다. 이렇게 하면 부모는 원래 작업을 계속하고, 자식은 새로운 프로그램을 실행할 수 있습니다.
- **파일 디스크립터 상속**: `exec()`가 호출되더라도 기존에 열려 있던 파일 디스크립터는 그대로 유지됩니다. 예를 들어, 네트워크 소켓이나 파일 핸들은 새로 실행된 프로그램에서도 사용할 수 있습니다.

### 6. `fork()`와 `exec()`의 결합 사용

`fork()`와 `exec()`는 자주 함께 사용됩니다. `fork()`는 부모 프로세스의 복사본인 자식 프로세스를 생성하고, 그 자식 프로세스가 `exec()`를 호출하여 다른 프로그램을 실행하게 됩니다. 이 방식은 프로세스 제어와 멀티프로세싱을 유연하게 구현하는 데 유용합니다.

#### 예시:
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // 자식 프로세스: exec()로 새로운 프로그램 실행
        char *args[] = {"ls", "-l", NULL};
        execvp("ls", args);
    } else if (pid > 0) {
        // 부모 프로세스: 자식 프로세스가 끝날 때까지 대기
        wait(NULL);
        printf("Child process finished.\n");
    } else {
        // fork 실패
        printf("Fork failed.\n");
    }

    return 0;
}
```

- `fork()`로 자식 프로세스를 생성한 후, 자식은 `execvp()`로 `ls` 명령을 실행합니다.
- 부모 프로세스는 `wait()`로 자식이 종료될 때까지 기다립니다.

---

### 요약

- **`exec()` 함수**는 현재 프로세스를 새로운 프로그램으로 완전히 대체하는 시스템 호출입니다.
- `exec()`는 성공 시 반환되지 않으며, 호출한 프로세스는 새로운 프로그램으로 전환됩니다.
- `exec()` 계열 함수는 인자 전달 방식에 따라 여러 변형이 있습니다.
- `fork()`와 함께 사용하여 자식 프로세스에서 새로운 프로그램을 실행하는 방식이 많이 사용됩니다.
