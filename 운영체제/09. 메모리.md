## 메모리

**메모리는 컴퓨터 시스템에서 데이터를 저장하고 처리하는 역할을 하는 하드웨어 장치이다.** 주로 CPU가 실행할 프로그램과 데이터를 저장하며, 다양한 종류로 분류된다.

1. **주기억장치 (Main Memory)**
   - **RAM (Random Access Memory):** 휘발성 메모리로, 전원이 차단되면 데이터가 사라집니다. 데이터를 읽고 쓰는 속도가 매우 빠르며, CPU와 직접적으로 상호작용합니다.
   - **ROM (Read Only Memory):** 비휘발성 메모리로, 전원이 차단되어도 데이터가 유지됩니다. 주로 시스템 부팅에 필요한 기본 프로그램을 저장합니다.

2. **보조기억장치 (Auxiliary Memory)**
   - 하드디스크, USB, CD-ROM 등과 같은 장치로, 대량의 데이터를 영구적으로 저장합니다.

3. **캐시 메모리 (Cache Memory)**
   - CPU와 주기억장치 사이에 위치하여 데이터 접근 속도를 향상시키는 휘발성 메모리입니다. 자주 사용되는 데이터나 프로그램을 저장하여 CPU의 처리 속도를 높입니다.

4. **레지스터 (Register)**
   - CPU 내부의 고속 기억장치로, 연산에 필요한 데이터를 임시로 저장합니다. 가장 빠른 속도를 가지지만 용량은 작습니다.

메모리는 컴퓨터 성능에 중요한 영향을 미치며, CPU의 효율적인 작동을 지원하기 위해 다양한 계층 구조를 가지고 있다.

### 커널 영역과 사용자 영역

운영체제는 메모리를 크게 두 가지의 영역으로 구분하여 사용한다. 메모리 제일 앞부분에 커널 영역에 해당하는 데이터를 잔뜩 몰아넣고, 그 이후의 빈 영역들을 전부 사용자 영역으로 사용한다.

## 주소 지정

컴퓨터가 메모리 내 데이터를 저장하거나 불러올 때 메모리의 주소를 지정하는 것을 '주소 지정'이라고 한다. 

### 절대 주소 지정

**데이터가 위치한 메모리 상의 실제 물리적인 주소를 지정한다.** 데이터가 100번지에 저장되어 있다면, 100이라는 숫자를 사용하여 주소를 지정한다.

**장점**

직접적이고 빠른 접근이 가능하다.

**단점** 

메모리 위치가 변경되면 주소도 변경해야 하며, 사용자가 운영체제 영역에 접근할 위험이 있다.

### 상대 주소 지정

**현재 메모리 위치(주로 프로그램 카운터)로부터의 상대적인 주소를 사용하여 지정한다.** 논리적 주소는 각 프로세스마다 독립적으로 할당되며, 0번지부터 시작한다. 이를 통해 운영체제가 메모리를 효율적으로 관리할 수 있으며, 다중 프로그래밍과 가상 메모리 같은 기능을 구현할 수 있게 됐다. 

**장점**
- 프로그램의 위치 독립성을 제공합니다.
- 운영체제 영역의 절대 위치를 알 필요가 없어 편리합니다.
- 사용자가 운영체제 영역에 실수로 접근하는 위험을 방지합니다.

## 메모리 할당 기법

*이 섹션에서는 외부 단편화와 내부 단편화에 대한 내용이 미리 언급된다. 해당 내용은 바로 아래 섹션에서 다루므로, 먼저 정의만 읽은 후 다음 섹션을 읽은 뒤에 다시 이 섹션을 읽는 것을 추천한다.*

### 연속 할당 기법(Contiguous Memory Allocation)

**연속 할당 기법은 하나의 프로세스를 메모리의 한 영역에 연속적으로 할당하는 방식이다.** 프로세스를 구성하는 전체 데이터를 통으로 메모리에 집어넣는 것이다. 하지만 메모리는 일정한 단위로 끊어진 주소값을 갖고 있기 때문에(64-bit 운영체제 기준 메모리 각 주소 당 64-bit(8-byte)의 데이터를 저장할 수 있다. 주소 또한 동일하게 64-bit(8-byte)로 표현함), 일단 데이터를 분할한 후 그것을 연속적으로 넣는 방식으로 구현해야 한다.

#### 고정 분할 방식

**프로세스의 메모리를 고정된 크기로 분할하는 방식이다.** 구현이 간단하다는 장점이 있으나, 내부 단편화와 외부 단편화 문제가 발생한다는 심각한 단점이 있다.

#### 가변 분할 방식

**프로세스 메모리의 총 크기에 따라 동적 크기로 메모리를 분할하는 방식이다.** 내부 단편화를 줄일 수 있다는 장점이 있으나, 외부 단편화가 발생할 수 있다는 단점이 있다.

가변 분할 방식은 크게 3가지의 할당 방법이 있다. 아래 세 가지 방식을 통틀어 `메모리 배치 기법`이라고 부른다.
- 최초적합(First-fit): 첫 번째로 발견되는 충분한 크기의 여유 메모리 공간에 할당
- 최적적합(Best-fit): 필요한 메모리 공간과 가장 크기가 비슷한 여유 메모리 공간에 할당
- 최악적합(Worst-fit): 현재 존재하는 가장 큰 여유 메모리 공간에 할당

최초적합과 최적적합의 경우 개선 효과가 있다는 연구 결과가 있다.

### 불연속/분산 할당 기법(Non-Contiguous Memory Allocation)

**불연속 할당 기법은 하나의 프로세스를 메모리의 여러 위치에 분산하여 할당하는 방식이다.** 앞서 말했듯 메모리는 일정한 단위로 끊어져 있는데, 여러 프로세스들을 메모리에 적재하다보면 중간 중간에 빈 메모리 공간이 생길 것이다. 그런 빈틈 사이로 새 프로세스의 메모리를 잘라서 채워넣음으로써 메모리를 절약하는 전략이다.

#### 페이징(Paging)

**프로세스(논리 메모리)를 일정한 크기의 페이지로 나누고 물리 메모리도 페이지와 같은 크기의 프레임으로 나눈 뒤, 메모리의 여러 위치에 분산하여 할당하는 방식이다.**  프로세스의 각 페이지는 논리 순서에 상관없이 물리 메모리의 프레임에 mapping되어 저장된다. 이렇게 흩어진 메모리에 대한 주소 바인딩을 위해, 모든 프로세스는 각각의 주소 변환을 위한 page table을 갖는다.

**장점**
- 외부 단편화 문제를 해결한다.
- 메모리 관리가 효율적이다.

**단점**
- 마지막 page에서 내부 단편화가 발생할 수 있다.(마지막 페이지는 프로세스 메모리의 나머지이니까.)
- page table 관리를 위해 추가적인 메모리를 사용해야 한다.

#### 세그멘테이션(Segmentation)

**프로세스를 논리적 단위(세그먼트)로 나누어 할당한다.** 논리적 단위는 주로 '프로세스의 주소 공간'에서 각 섹션 별로 정의하는 경우가 많다.('[프로세스](06.%20프로세스.md)' 장 참고) segmentation 기법도 흩어진 메모리를 주소 바인딩해야 하기 때문에, 각 프로세스는 저마다의 주소 변환을 위한 segement table을 갖는다.

**장점**
- 내부 단편화가 발생하지 않는다.
- 코드 공유와 보호가 용이하다.

**단점**
- 외부 단편화가 발생할 수 있다.
- segment table 관리에 추가적인 메모리를 사용해야 한다.

## 단편화(Fragmentation)

**단편화는 기억 장치의 빈 공간 또는 자료가 여러 개의 조각으로 나뉘는 현상이다.** 

### 내부 단편화(Internal Fragmentation)

**프로세스에 할당된 메모리 공간이 실제 필요한 양보다 클 때 발생하는 현상을 말한다.** 이러한 현상은 특히 paging 기법을 사용할 때 흔히 볼 수 있는데, 마지막 page는 메모리에 할당될 frame 크기보다 작을 가능성이 높으므로 내부 단편화를 피하갈 수 없다.

### 외부 단편화(Extermal Framgentation)

**빈 메모리 공간을 전부 모으면 충분히 하나의 프로세스를 더 로드할 수 있는데, 사용 중인 블록 사이 사이에 추가적인 블록을 넣을 공간이 부족해 프로세스를 할당할 수 없는 현상을 말한다.** 연속할당 기법을 사용할 때 피할 수 없는 문제이다.

### 외부 단편화 문제 해결 방법

- **압축(Compaction)**: 사용 중인 메모리 블록들을 한 방향으로 쭉 끌어모아 빈 공간을 확보하는 방법. 성능 효율이 최악이라 자주 사용되지는 않는다.
- **Paging**: 물리 메모리 공간과 프로세스 메모리를 각각 프레임과 페이지로 나누어 빈 프레임에 페이지를 꽃아 넣는 방식. 외부 단편화 문제는 확실히 해결되지만 내부 단편화 문제는 피할 수 없다.
- **메모리 풀(Memory Pool)**: 필요한 메모리 공간을 미리 할당받아 놓은 후, 필요할 때 메모리를 쓰고 다 썼으면 반납하는 전략.

## 메모리 반입 기법

**프로그램이나 데이터를 주기억장치(메인 메모리)에 언제 적재할지를 결정하는 메모리 관리 전략.** 크게 필요할 때 데이터를 메모리에 적재하거나, 필요할 것이라고 예상될 때 미리 메모리에 적재하는 방법으로 나뉜다.

### 요구 반입 기법(Demand Fetch):

**프로세스가 실제로 필요로 할 때만 메모리에 적재하는 기법.** 프로세스 실행 중 메모리 부재(memory miss)가 발생할 때마다 해당 페이지를 메모리에 로드한다. 이 기법을 사용하면 메모리 상에 존재하는 데이터들은 전부 실제 사용 중인 데이터들 뿐이므로 효율적으로 물리 메모리를 사용할 수 있다는 장점이 있다. 하지만 매번 메모리 부재를 겪을 때마다 물리 메모리에 로드하는 행동을 취해야 하므로 딜레이가 발생하는 것이 심각한 단점이다.

### 예상 반입 기법(Prefetch)

**앞으로 필요할 것으로 예상되는 데이터나 프로그램을 미리 메모리에 적재하는 기법.** 프로세스의 실행 패턴을 분석하여 미리 필요할 것 같은 데이터들을 로드하는 전략이다. 미리 세팅을 해두기 때문에 메모리 부재 발생 빈도가 크게 줄어 성능이 향상된다는 엄청난 장점이 있다. 하지만 메모리 사용량은 요구 반입 기법보다 증가할 수밖에 없으며, 예측이 틀린 경우에는 자원 낭비라는 결과를 초래한다는 심각한 단점이 있다.

## 가상 메모리(Virtual Memory)

**실제 물리적 메모리의 크기에 제한받지 않고 더 큰 주소 공간을 사용할 수 있게 해주는 기술.** 가상 메모리는 주로 메모리 불연속/분산 할당 기법 중 'paging' 기법과 메모리 반입 기법 중 '요구 반입 기법(Demand Fetch)'을 응용하여 구현한다. 

### 가상 주소와 물리 주소

**물리 주소**

**실제 메모리(RAM)의 물리적 위치를 나타내는 주소.** 절대 주소 지정 시 사용하는 주소이다. 

**가상 주소**

**CPU가 생성하고 프로그램이 사용하는 논리적인 주소.** 상대 주소 지정 시 사용하는 주소이다. 

가상 주소와 물리 주소 간의 변환은 메모리 관리 장치(MMU)에 의해 수행된다. 이 과정을 통해 프로그램은 연속적인 메모리 공간을 사용하는 것처럼 동작할 수 있으며, 실제로는 물리적 메모리의 여러 위치에 분산되어 저장될 수 있다. 이러한 메커니즘은 메모리 사용의 효율성을 높이고, 여러 프로세스가 동시에 실행될 수 있게 하는 엄청난 장점을 갖는다.

### 페이지 교체 기법

**가상 메모리의 운영 방식은 paging 할당 기법에서의 요구 반입 기법(Demand Fetch)을 지칭하는 `요구 페이징(Demand Paging)`을 기반으로 한다.** 요구 페이징은 페이지 폴트(Page Fault, 페이지 부재)가 발생할 때마다 해당 페이지를 디스크로부터 물리 메모리에 로드하는 방식이다. 최초 로드 시 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽기 때문에, 당장 사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다는 엄청난 장점을 갖는다.

그러나 이 방식에는 심각한 문제가 있다. 물리 메모리가 가득 찼을 경우, 기존의 페이지들 중 어떤 페이지를 제거한 후 갈아 끼워야 하냐는 논점이다. 그래서 전문가들은 아래와 같은 페이지 교체 기법들을 고안했다. 목표는 페이지 부재율을 최소화하는 것이다.

[같이 보면 좋은 자료](https://zangzangs.tistory.com/143)

#### FIFO(First In First Out, 선입선출)

**가장 먼저 로드된 페이지를 우선적으로 제거하는 방식.** 구현하기 쉽다는 장점이 있지만, 오래된 페이지라고 해서 불필요한 정보를 담고 있다고 보장할 수 없으며, 이미 활발하게 사용 중인 오래된 페이지를 제거할 수 있는 문제점이 있다.

#### LRU(Least Recently Used)

**가장 오랫동안 사용하지 않은 페이지를 우선적으로 제거하는 방식.** FIFO 보다 성능적으로 우수하다.

#### LFU(Least Frequently Used)

**총 참조 횟수가 가장 적은 페이지를 우선적으로 제거하는 방식.** 하지만 이 방식은 누적 참조 횟수가 절대적으로 적은 최근에 교체된 페이지들에게 불리한 조건이라서 성능적으로 이점이 크지 않기 때문에 잘 쓰이지 않는다.

#### Clock Algorithm

클럭 알고리즘은 참조 비트(reference bit)를 순차적으로 조사하며 동작한다. 
1. 프레임 내의 페이지가 참조될 때마다 하드웨어에 의해 1로 자동 세팅된다.
2. 클럭 알고리즘은 한 바퀴 돌며 참조되지 않은 페이지의 참조 비트 값을 0으로 바꾼 후 지나간다.
3. 참조 비트가 0인 페이지를 방문하면 해당 페이지를 교체한다.

결과적으로 매 사이클마다 최소 1번씩 사용된 페이지들은 생존하고, 사이클 내에 사용되지 못한 페이지들은 교체당하는 전략이다. 이러한 특성으로 클럭 알고리즘을 '2차 기회 알고리즘'이라고 부르기도 한다.

## 쓰레싱(Thrashing)

**프로세스가 메모리 특정 한계점부터 실제 실행 시간보다 더 많은 시간을 페이징에 사용하는 현상.** 메모리에 적재되지 못한 페이지들을 마주하는 페이지 폴트 현상이 빈번하게 발생하면, 페이지 교체가 자주 일어나며 교체 비용이 크게 증가하게 되는 것이다. 이렇게 되면 CPU 이용률이 저하되고, 잦은 페이지 swap으로 인해 디스크 접근이 급증하는 심각한 문제가 생긴다.

### 해결방안

#### 작업 집합 모델(Working Set Model)

> 작업 집합(Working Set): 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합

작업 집합을 활용하여 메모리를 조절하는 방법. 작업 집합을 만들기 위해서는 '지역성의 원리(Locality)'를 사용해야 한다. 

**지역성의 원리는 프로세스가 특정 부분을 집중적으로 참조하는 경향을 말한다.** 지역성은 크게 두 가지가 존재한다.
-  **시간 지역성(Temporal Locality)**: 최근 참조된 데이터가 가까운 미래에 다시 참조되는 정도
-  **공간 지역성(Spatial Locality)**: 참조된 데이터의 주변 데이터가 함께 참조되는 정도

**동작 방식**

시스템이 각 프로세스의 작업 집합 크기를 주기적으로 모니터링한다. 그러다가 모든 프로세스의 작업 집합 요구량 합이 가용 프레임을 초과한 것을 감지하면, 일부 프로세스를 중지하고 해당 페이지를 다른 프로세스에 할당한다.

#### PFF(Page Fault Frequency, 페이지 부재 빈도)

 **각 프로세스의 페이지 부재율에 따라 할당할 프레임 수를 예측하고 조절하는 방법.** 작업 집합 모델보다 구현이 쉬우며, 직접 페이지 부재율을 관리하여 쓰레싱을 효과적으로 방지할 수 있다는 장점이 있다. 

**동작 방식**

 1. 페이지 부재율의 상한과 하한을 설정한다.
    - 페이지 부재율이 상한을 넘으면 해당 프로세스에 더 많은 프레임을 할당한다.
    - 페이지부재율이 하한보다 낮으면 프로세스의 프레임 수를 줄인다.
 2. 더 이상 할당할 프레임이 없으면, 일부 프로세스를 중단하고 그 프레임을 재분배한다.

적절한 상한과 하한을 설정하는 것이 PFF 방식의 핵심이다.