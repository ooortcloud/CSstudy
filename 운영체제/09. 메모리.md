## 메모리

**메모리는 컴퓨터 시스템에서 데이터를 저장하고 처리하는 역할을 하는 하드웨어 장치이다.** 주로 CPU가 실행할 프로그램과 데이터를 저장하며, 다양한 종류로 분류된다.

1. **주기억장치 (Main Memory)**
   - **RAM (Random Access Memory):** 휘발성 메모리로, 전원이 차단되면 데이터가 사라집니다. 데이터를 읽고 쓰는 속도가 매우 빠르며, CPU와 직접적으로 상호작용합니다.
   - **ROM (Read Only Memory):** 비휘발성 메모리로, 전원이 차단되어도 데이터가 유지됩니다. 주로 시스템 부팅에 필요한 기본 프로그램을 저장합니다.

2. **보조기억장치 (Auxiliary Memory)**
   - 하드디스크, USB, CD-ROM 등과 같은 장치로, 대량의 데이터를 영구적으로 저장합니다.

3. **캐시 메모리 (Cache Memory)**
   - CPU와 주기억장치 사이에 위치하여 데이터 접근 속도를 향상시키는 휘발성 메모리입니다. 자주 사용되는 데이터나 프로그램을 저장하여 CPU의 처리 속도를 높입니다.

4. **레지스터 (Register)**
   - CPU 내부의 고속 기억장치로, 연산에 필요한 데이터를 임시로 저장합니다. 가장 빠른 속도를 가지지만 용량은 작습니다.

메모리는 컴퓨터 성능에 중요한 영향을 미치며, CPU의 효율적인 작동을 지원하기 위해 다양한 계층 구조를 가지고 있다.

### 커널 영역과 사용자 영역

운영체제는 메모리를 크게 두 가지의 영역으로 구분하여 사용한다. 메모리 제일 앞부분에 커널 영역에 해당하는 데이터를 잔뜩 몰아넣고, 그 이후의 빈 영역들을 전부 사용자 영역으로 사용한다.

## 주소 지정

컴퓨터가 메모리 내 데이터를 저장하거나 불러올 때 메모리의 주소를 지정하는 것을 '주소 지정'이라고 한다. 

### 절대 주소 지정

**데이터가 위치한 메모리 상의 실제 물리적인 주소를 지정한다.** 데이터가 100번지에 저장되어 있다면, 100이라는 숫자를 사용하여 주소를 지정한다.

**장점**

직접적이고 빠른 접근이 가능하다.

**단점** 

메모리 위치가 변경되면 주소도 변경해야 하며, 사용자가 운영체제 영역에 접근할 위험이 있다.

### 상대 주소 지정

**현재 메모리 위치(주로 프로그램 카운터)로부터의 상대적인 주소를 사용하여 지정한다.** 논리적 주소는 각 프로세스마다 독립적으로 할당되며, 0번지부터 시작한다. 이를 통해 운영체제가 메모리를 효율적으로 관리할 수 있으며, 다중 프로그래밍과 가상 메모리 같은 기능을 구현할 수 있게 됐다. 

**장점**
- 프로그램의 위치 독립성을 제공합니다.
- 운영체제 영역의 절대 위치를 알 필요가 없어 편리합니다.
- 사용자가 운영체제 영역에 실수로 접근하는 위험을 방지합니다.

## 메모리 할당 기법

*이 섹션에서는 외부 단편화와 내부 단편화에 대한 내용이 미리 언급된다. 해당 내용은 바로 아래 섹션에서 다루므로, 먼저 정의만 읽은 후 다음 섹션을 읽은 뒤에 다시 이 섹션을 읽는 것을 추천한다.*

### 연속 할당 기법(Contiguous Memory Allocation)

**연속 할당 기법은 하나의 프로세스를 메모리의 한 영역에 연속적으로 할당하는 방식이다.** 프로세스를 구성하는 전체 데이터를 통으로 메모리에 집어넣는 것이다. 하지만 메모리는 일정한 단위로 끊어진 주소값을 갖고 있기 때문에(64-bit 운영체제 기준 메모리 각 주소 당 64-bit(8-byte)의 데이터를 저장할 수 있다. 주소 또한 동일하게 64-bit(8-byte)로 표현함), 일단 데이터를 분할한 후 그것을 연속적으로 넣는 방식으로 구현해야 한다.

#### 고정 분할 방식

**프로세스의 메모리를 고정된 크기로 분할하는 방식이다.** 구현이 간단하다는 장점이 있으나, 내부 단편화와 외부 단편화 문제가 발생한다는 심각한 단점이 있다.

#### 가변 분할 방식

**프로세스 메모리의 총 크기에 따라 동적 크기로 메모리를 분할하는 방식이다.** 내부 단편화를 줄일 수 있다는 장점이 있으나, 외부 단편화가 발생할 수 있다는 단점이 있다.

가변 분할 방식은 크게 3가지의 할당 방법이 있다. 아래 세 가지 방식을 통틀어 `메모리 배치 기법`이라고 부른다.
- 최초적합(First-fit): 첫 번째로 발견되는 충분한 크기의 여유 메모리 공간에 할당
- 최적적합(Best-fit): 필요한 메모리 공간과 가장 크기가 비슷한 여유 메모리 공간에 할당
- 최악적합(Worst-fit): 현재 존재하는 가장 큰 여유 메모리 공간에 할당

최초적합과 최적적합의 경우 개선 효과가 있다는 연구 결과가 있다.

### 불연속/분산 할당 기법(Non-Contiguous Memory Allocation)

**불연속 할당 기법은 하나의 프로세스를 메모리의 여러 위치에 분산하여 할당하는 방식이다.** 앞서 말했듯 메모리는 일정한 단위로 끊어져 있는데, 여러 프로세스들을 메모리에 적재하다보면 중간 중간에 빈 메모리 공간이 생길 것이다. 그런 빈틈 사이로 새 프로세스의 메모리를 잘라서 채워넣음으로써 메모리를 절약하는 전략이다.

#### 페이징(Paging)

**프로세스(논리 메모리)를 일정한 크기의 페이지로 나누고 물리 메모리도 페이지와 같은 크기의 프레임으로 나눈 뒤, 메모리의 여러 위치에 분산하여 할당하는 방식이다.**  프로세스의 각 페이지는 논리 순서에 상관없이 물리 메모리의 프레임에 mapping되어 저장된다. 이렇게 흩어진 메모리에 대한 주소 바인딩을 위해, 모든 프로세스는 각각의 주소 변환을 위한 page table을 갖는다.

**장점**
- 외부 단편화 문제를 해결한다.
- 메모리 관리가 효율적이다.

**단점**
- 마지막 page에서 내부 단편화가 발생할 수 있다.(마지막 페이지는 프로세스 메모리의 나머지이니까.)
- page table 관리를 위해 추가적인 메모리를 사용해야 한다.

#### 세그멘테이션(Segmentation)

**프로세스를 논리적 단위(세그먼트)로 나누어 할당한다.** 논리적 단위는 주로 '프로세스의 주소 공간'에서 각 섹션 별로 정의하는 경우가 많다.('[프로세스](06.%20프로세스.md)' 장 참고) segmentation 기법도 흩어진 메모리를 주소 바인딩해야 하기 때문에, 각 프로세스는 저마다의 주소 변환을 위한 segement table을 갖는다.

**장점**
- 내부 단편화가 발생하지 않는다.
- 코드 공유와 보호가 용이하다.

**단점**
- 외부 단편화가 발생할 수 있다.
- segment table 관리에 추가적인 메모리를 사용해야 한다.

## 단편화(Fragmentation)

**단편화는 기억 장치의 빈 공간 또는 자료가 여러 개의 조각으로 나뉘는 현상이다.** 

### 내부 단편화(Internal Fragmentation)

**프로세스에 할당된 메모리 공간이 실제 필요한 양보다 클 때 발생하는 현상을 말한다.** 이러한 현상은 특히 paging 기법을 사용할 때 흔히 볼 수 있는데, 마지막 page는 메모리에 할당될 frame 크기보다 작을 가능성이 높으므로 내부 단편화를 피하갈 수 없다.

### 외부 단편화(Extermal Framgentation)

**빈 메모리 공간을 전부 모으면 충분히 하나의 프로세스를 더 로드할 수 있는데, 사용 중인 블록 사이 사이에 추가적인 블록을 넣을 공간이 부족해 프로세스를 할당할 수 없는 현상을 말한다.** 연속할당 기법을 사용할 때 피할 수 없는 문제이다.

### 외부 단편화 문제 해결 방법

- **압축(Compaction)**: 사용 중인 메모리 블록들을 한 방향으로 쭉 끌어모아 빈 공간을 확보하는 방법. 성능 효율이 최악이라 자주 사용되지는 않는다.
- **Paging**: 물리 메모리 공간과 프로세스 메모리를 각각 프레임과 페이지로 나누어 빈 프레임에 페이지를 꽃아 넣는 방식. 외부 단편화 문제는 확실히 해결되지만 내부 단편화 문제는 피할 수 없다.
- **메모리 풀(Memory Pool)**: 필요한 메모리 공간을 미리 할당받아 놓은 후, 필요할 때 메모리를 쓰고 다 썼으면 반납하는 전략.

## 반입 기법

**프로그램이나 데이터를 주기억장치(메인 메모리)에 언제 적재할지를 결정하는 메모리 관리 전략.** 크게 필요할 때 데이터를 메모리에 적재하거나, 필요할 것이라고 예상될 때 미리 메모리에 적재하는 방법으로 나뉜다.

### 요구 반입 기법(Demand Fetch):

**프로세스가 실제로 필요로 할 때만 메모리에 적재하는 기법.** 프로세스 실행 중 메모리 부재(memory miss)가 발생할 때마다 해당 페이지를 메모리에 로드한다. 이 기법을 사용하면 메모리 상에 존재하는 데이터들은 전부 실제 사용 중인 데이터들 뿐이므로 효율적으로 물리 메모리를 사용할 수 있다는 장점이 있다. 하지만 매번 메모리 부재를 겪을 때마다 물리 메모리에 로드하는 행동을 취해야 하므로 딜레이가 발생하는 것이 심각한 단점이다.

### 예상 반입 기법(Prefetch)

**앞으로 필요할 것으로 예상되는 데이터나 프로그램을 미리 메모리에 적재하는 기법.** 프로세스의 실행 패턴을 분석하여 미리 필요할 것 같은 데이터들을 로드하는 전략이다. 미리 세팅을 해두기 때문에 메모리 부재 발생 빈도가 크게 줄어 성능이 향상된다는 엄청난 장점이 있다. 하지만 메모리 사용량은 요구 반입 기법보다 증가할 수밖에 없으며, 예측이 틀린 경우에는 자원 낭비라는 결과를 초래한다는 심각한 단점이 있다.

## 가상 메모리(Virtual Memory)



### 가상 주소와 물리 주소

### 페이지 교체 기법

#### FIFO(First In First Out, 선입선출)

#### LRU(Least Recently Used)


#### LFU(Least Frequently Used)


#### Clock Algorithm


## 쓰레싱(Thrashing)

### 문제점

### 해결방안

#### 워킹 셋(Working Set)

#### PFF(Page Fault Frequency, 페이지 부재 빈도)