**스레드(Thread)**는 프로세스 내에서 실행되는 작업의 단위로, 프로세스가 실행할 코드의 흐름을 나타냅니다. 스레드는 **프로세스 내의 경량 실행 단위**로, 프로세스의 자원을 공유하며 동시에 여러 작업을 병렬로 수행할 수 있습니다. 프로세스와 달리 스레드는 메모리를 공유하기 때문에 더 가볍고, 효율적으로 동작합니다.

## 쓰레드의 개념
### 1. 스레드란

하나의 프로세스는 최소 하나의 스레드를 가지고 있으며, 이 스레드는 **메인 스레드**라 불립니다. 멀티스레드 프로그래밍에서는 하나의 프로세스 내에서 여러 스레드가 동시에 실행되며, 각각의 스레드가 프로세스의 메모리(코드, 데이터, 힙, 파일 디스크립터 등)를 공유합니다.

#### 주요 특징:
- **경량성**: 스레드는 프로세스보다 가볍고, 메모리 및 자원 사용이 적습니다.
- **자원 공유**: 같은 프로세스 내의 스레드들은 동일한 메모리 공간과 자원을 공유하여 통신이 빠릅니다.
- **병렬 실행**: 멀티스레드 프로그램은 여러 스레드가 동시에 실행되어, 병렬 처리로 성능을 높일 수 있습니다.

### 2. 스레드와 프로세스의 차이

| 비교 항목            | 프로세스                             | 스레드                               |
|----------------------|--------------------------------------|--------------------------------------|
| 메모리               | 프로세스마다 독립된 메모리 공간 사용  | 동일한 프로세스 내에서 메모리 공유  |
| 생성 비용            | 프로세스 생성 비용이 큼               | 스레드 생성 비용이 상대적으로 적음   |
| 통신 방식            | 프로세스 간에는 IPC 방식 필요         | 스레드 간에는 메모리 공유로 통신    |
| 자원 공유            | 각 프로세스는 자원을 독립적으로 사용 | 스레드는 자원과 메모리를 공유       |
| 안정성               | 하나의 프로세스가 종료되어도 다른 프로세스에 영향 없음 | 하나의 스레드가 문제를 일으키면 전체 프로세스에 영향 미칠 수 있음 |

### 3. 멀티스레드의 장점

#### 3.1. 성능 향상
스레드들은 동시에 실행될 수 있기 때문에 멀티코어 CPU에서는 각 코어가 서로 다른 스레드를 처리할 수 있습니다. 이를 통해 병렬 처리 성능이 향상됩니다.

[멀티코어란](./세부%20개념/멀티코어.md)

#### 3.2. 자원 효율성
스레드는 프로세스 내의 자원을 공유하기 때문에 별도의 메모리 할당 없이 스레드 간 통신이 가능합니다. 프로세스 간 통신(IPC)보다 더 효율적이며, 메모리 사용도 적습니다.

#### 3.3. 응답성 향상
응답 시간이 중요한 애플리케이션(예: 웹 서버, 게임)은 멀티스레드를 사용하여 작업을 분리하고, 하나의 스레드가 긴 작업을 처리하는 동안 다른 스레드가 사용자 인터페이스와의 상호작용을 처리할 수 있습니다.

### 4. 멀티스레드의 단점

#### 4.1. 동기화 문제
스레드 간 메모리를 공유하기 때문에 **동시성 문제**가 발생할 수 있습니다. 여러 스레드가 동일한 자원에 동시에 접근하는 경우, 데이터 충돌이나 **경쟁 상태(race condition)**가 발생할 수 있습니다. 이를 해결하기 위해 **뮤텍스(Mutex)**, **세마포어(Semaphore)** 등의 동기화 메커니즘이 필요합니다.

#### 4.2. 디버깅의 어려움
멀티스레드 프로그램은 여러 스레드가 동시에 실행되기 때문에 오류 발생 시 디버깅이 어렵습니다. 특히, 동시성 오류는 재현하기 어려워 문제 해결이 복잡해질 수 있습니다.

#### 4.3. 자원 공유의 복잡성
스레드는 자원을 공유하기 때문에, 자원 관리가 복잡해질 수 있습니다. 메모리 누수, 교착 상태(deadlock), 기아 상태(livelock) 등 다양한 문제가 발생할 수 있습니다.

### 5. 스레드 생성 및 관리

스레드는 다양한 프로그래밍 언어에서 지원되며, 대표적으로 **C, C++, Java, Python**에서 스레드를 쉽게 사용할 수 있습니다. 운영체제는 스레드를 스케줄링하여 CPU에 할당하고, 이를 통해 병렬 처리가 가능합니다.

#### 5.1. POSIX 스레드(Pthreads)
C 언어에서는 POSIX 스레드(Pthreads) 라이브러리를 사용하여 스레드를 생성하고 관리할 수 있습니다.

```c
#include <stdio.h>
#include <pthread.h>

void* thread_function(void* arg) {
    printf("Hello from the thread!\n");
    return NULL;
}

int main() {
    pthread_t thread;
    
    // 스레드 생성
    pthread_create(&thread, NULL, thread_function, NULL);
    
    // 메인 스레드가 자식 스레드가 끝날 때까지 대기
    pthread_join(thread, NULL);
    
    printf("Thread has finished execution.\n");
    return 0;
}
```

- `pthread_create()` 함수는 새로운 스레드를 생성하고, 해당 스레드에서 `thread_function()` 함수를 실행합니다.
- `pthread_join()` 함수는 메인 스레드가 자식 스레드의 실행이 끝날 때까지 기다리도록 합니다.

#### 5.2. Java에서의 스레드 생성
Java에서는 `Thread` 클래스를 상속하거나, `Runnable` 인터페이스를 구현하여 스레드를 생성할 수 있습니다.

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Hello from the thread!");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();  // 스레드 시작
    }
}
```

- `start()` 메서드를 호출하면 스레드가 생성되고, `run()` 메서드가 실행됩니다.
- Java에서 스레드는 JVM(Java Virtual Machine)에 의해 관리되며, 스레드 간 동기화를 위해 `synchronized` 키워드나 `Lock` 클래스를 사용할 수 있습니다.

### 6. 스레드 동기화

멀티스레드 환경에서 스레드 간 동기화는 매우 중요한 역할을 합니다. 공유 자원에 여러 스레드가 동시에 접근하는 경우 데이터의 일관성을 유지하기 위해 동기화가 필요합니다.

#### 6.1. 뮤텍스(Mutex)
뮤텍스는 하나의 스레드만 공유 자원에 접근할 수 있도록 보장하는 동기화 메커니즘입니다. 뮤텍스를 사용하여 공유 자원에 접근하는 코드 영역을 임계 구역(critical section)으로 지정할 수 있습니다.

```c
#include <stdio.h>
#include <pthread.h>

int shared_data = 0;
pthread_mutex_t lock;

void* thread_function(void* arg) {
    pthread_mutex_lock(&lock);  // 뮤텍스 잠금
    shared_data++;
    printf("Shared data: %d\n", shared_data);
    pthread_mutex_unlock(&lock);  // 뮤텍스 잠금 해제
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&lock, NULL);  // 뮤텍스 초기화
    
    pthread_create(&t1, NULL, thread_function, NULL);
    pthread_create(&t2, NULL, thread_function, NULL);
    
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    pthread_mutex_destroy(&lock);  // 뮤텍스 소멸
    return 0;
}
```

- `pthread_mutex_lock()`과 `pthread_mutex_unlock()`을 통해 임계 구역을 설정하여, 한 번에 하나의 스레드만 자원에 접근할 수 있도록 합니다.

#### 6.2. 세마포어(Semaphore)
세마포어는 정해진 수의 스레드가 동시에 자원에 접근할 수 있도록 하는 동기화 기법입니다. 자원에 접근할 수 있는 스레드의 최대 수를 지정할 수 있으며, 이를 통해 임계 구역의 동시성을 제어합니다.

### 7. 스레드 사용 사례

#### 7.1. 웹 서버
웹 서버는 다중 클라이언트의 요청을 처리하기 위해 멀티스레드를 사용합니다. 각 클라이언트 요청은 독립된 스레드에서 처리되며, 이를 통해 동시에 많은 요청을 처리할 수 있습니다.

#### 7.2. GUI 애플리케이션
GUI 애플리케이션은 사용자 인터페이스가 멈추지 않고 응답성을 유지하기 위해 백그라운드에서 작업을 처리하는 데 멀티스레드를 사용합니다. 예를 들어, 파일 다운로드 중에도 UI는 계속해서 사용자 입력을 받을 수 있습니다.

#### 7.3. 데이터베이스 서버
데이터베이스 서버는 여러 클라이언트의 쿼리를 병렬로 처리하기 위해 멀티스레드를 사용합니다. 이를 통해 대규모 데이터 처리 성능을 향상시킬 수 있습니다.

### 요약

- **스레드**는 프로세스 내에서 실행되는 경량의 실행 단위로, 프로세스의 자원을 공유하며 동시에 여러 작업을 수행할 수 있습니다.
- 스레드는 성능 향상과 자원 효율성 면에서 장점을 제공하지만, 동기화 문제와 자원 관리의 복잡성이 있습니다.
- 멀티스레드 프로그램에서는 동기화 메커니즘을 통해 스레드 간의 경쟁 상태를 방지해야 합니다.


## 쓰레드의 메모리 구조
스레드는 프로세스 내에서 실행되는 경량 실행 단위로, **프로세스와 동일한 메모리 공간**을 공유합니다. 하지만, 스레드는 독립적으로 실행되기 때문에, 스레드가 사용하는 메모리 공간은 프로세스의 메모리 구조 안에서 특정한 방식으로 나뉘어집니다. 이를 이해하기 위해서는 프로세스의 메모리 구조를 먼저 이해할 필요가 있습니다.

### 1. 프로세스의 메모리 구조

프로세스는 운영체제에 의해 다음과 같은 메모리 영역으로 나뉘어집니다:

- **코드 영역 (Text Segment)**: 실행할 코드가 저장되는 영역입니다. 이 영역은 읽기 전용이며, 모든 스레드가 공유합니다.
- **데이터 영역 (Data Segment)**: 전역 변수와 정적 변수가 저장되는 공간으로, 모든 스레드가 공유합니다.
- **힙 영역 (Heap Segment)**: 동적으로 할당된 메모리가 저장되는 공간으로, 모든 스레드가 공유합니다.
- **스택 영역 (Stack Segment)**: 각 스레드가 독립적으로 사용하는 메모리 공간입니다. 함수 호출 시의 지역 변수, 함수 인자, 리턴 주소 등이 저장됩니다.

### 2. 스레드의 메모리 구조

스레드는 **프로세스의 대부분의 메모리 영역을 공유**하지만, **각 스레드마다 독립적인 스택 공간을 가집니다**. 스레드의 메모리 구조는 다음과 같이 나눌 수 있습니다:

#### 2.1. 공유되는 메모리 영역
스레드는 프로세스 내에서 **코드, 데이터, 힙 영역**을 모두 공유합니다.

- **코드 영역**: 모든 스레드는 동일한 코드 영역을 공유합니다. 이는 스레드들이 동일한 프로그램 코드를 실행할 수 있음을 의미합니다.
- **데이터 영역**: 전역 변수와 정적 변수는 모든 스레드가 공유하며, 이로 인해 동시성 문제가 발생할 수 있습니다. 따라서 여러 스레드가 같은 전역 변수에 접근할 때는 **동기화**가 필요합니다.
- **힙 영역**: 동적으로 할당된 메모리도 모든 스레드가 공유합니다. 힙 메모리 역시 동시 접근이 이루어질 수 있기 때문에, 이 경우에도 **동기화**가 필요합니다.

#### 2.2. 스레드마다 독립적인 메모리 영역
각 스레드는 독립된 **스택 영역**을 가지고 있습니다. 스택은 함수 호출과 관련된 데이터를 저장하는데 사용되며, 스레드마다 독립적이기 때문에 다른 스레드의 스택 데이터를 접근할 수 없습니다.

- **스택 영역**: 스레드마다 독립된 스택을 가지고 있어, 함수 호출 시의 지역 변수, 함수 인자, 리턴 주소 등이 저장됩니다. 스레드 간 스택은 격리되어 있어, 한 스레드가 다른 스레드의 스택에 접근할 수 없습니다.
  
### 3. 스레드 메모리 구조의 장단점

#### 장점:
1. **효율적인 메모리 사용**: 스레드는 프로세스 내에서 메모리 자원을 공유하기 때문에, 각 스레드가 독립적으로 실행되면서도 메모리 낭비가 적습니다.
2. **빠른 통신**: 스레드 간 통신은 같은 프로세스의 메모리 공간에서 이루어지므로, 별도의 IPC(Inter-Process Communication) 방식 없이도 빠르게 데이터를 주고받을 수 있습니다.

#### 단점:
1. **동기화 문제**: 여러 스레드가 공유 메모리 영역(특히 데이터와 힙)에 접근하기 때문에, 동시 접근에 따른 충돌이나 일관성 문제(**race condition**)가 발생할 수 있습니다. 이를 해결하기 위해 **뮤텍스(Mutex)**, **세마포어(Semaphore)** 등의 동기화 메커니즘을 사용해야 합니다.
2. **스택 오버플로우**: 스레드마다 할당된 스택의 크기는 고정되어 있기 때문에, 스택 공간을 초과하는 재귀 호출이나 과도한 지역 변수 사용은 **스택 오버플로우**를 유발할 수 있습니다.

### 4. 스레드 메모리 구조 예시

#### 예시 1: 전역 변수 공유
```c
#include <pthread.h>
#include <stdio.h>

int shared_data = 0;  // 전역 변수 (모든 스레드가 공유)

void* thread_function(void* arg) {
    for (int i = 0; i < 1000; i++) {
        shared_data++;  // 여러 스레드가 같은 변수를 수정
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    
    pthread_create(&t1, NULL, thread_function, NULL);
    pthread_create(&t2, NULL, thread_function, NULL);
    
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    printf("Shared Data: %d\n", shared_data);  // 예상치 못한 값 출력 가능 (경쟁 상태 발생)
    return 0;
}
```

- 이 코드에서 전역 변수 `shared_data`는 모든 스레드가 공유합니다. 하지만 스레드가 동시 접근할 경우, 예상치 못한 값이 출력될 수 있습니다. 이를 **경쟁 상태**라 하며, 동기화 없이 여러 스레드가 동일한 자원을 수정할 때 발생합니다.

#### 예시 2: 스택 독립성
```c
#include <pthread.h>
#include <stdio.h>

void* thread_function(void* arg) {
    int local_var = 0;  // 지역 변수 (각 스레드마다 독립)
    for (int i = 0; i < 1000; i++) {
        local_var++;
    }
    printf("Local Var: %d\n", local_var);
    return NULL;
}

int main() {
    pthread_t t1, t2;
    
    pthread_create(&t1, NULL, thread_function, NULL);
    pthread_create(&t2, NULL, thread_function, NULL);
    
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    return 0;
}
```

- 이 코드에서 `local_var`는 각 스레드가 독립적으로 사용하는 지역 변수입니다. 따라서 스레드 간에는 이 변수에 대한 충돌이 발생하지 않으며, 각각의 스레드에서 독립된 값을 가집니다.

### 요약

- 스레드는 프로세스의 **코드, 데이터, 힙 영역**을 공유하지만, **스택 영역**은 스레드마다 독립적으로 존재합니다.
- 공유되는 메모리 영역에서는 **동기화 문제**가 발생할 수 있어, 동기화 메커니즘을 통해 자원 접근을 제어해야 합니다.
- 스레드마다 독립된 스택을 사용하여, 지역 변수와 함수 호출 데이터를 저장합니다. 하지만 스택 크기에 주의해야 하며, 스택 오버플로우가 발생하지 않도록 설계해야 합니다.


## TCB

**쓰레드 제어 블록 (Thread Control Block, TCB)**은 운영체제가 각 스레드를 관리하기 위해 사용하는 데이터 구조입니다. 프로세스의 실행 상태를 관리하는 **프로세스 제어 블록(PCB)**처럼, 스레드도 **TCB**를 통해 스레드의 상태 및 정보를 관리합니다.

### TCB의 주요 요소
TCB는 각 스레드에 대한 다양한 정보를 포함하고 있으며, 주요 요소는 다음과 같습니다:

1. **스레드 ID (Thread ID)**  
   각 스레드를 식별하기 위한 고유한 ID입니다. 프로세스 내에서 다수의 스레드가 실행되므로, 각 스레드마다 구별되는 식별 번호가 필요합니다.

2. **스레드 상태 (Thread State)**  
   스레드가 현재 어떤 상태에 있는지를 나타냅니다. 상태는 일반적으로 **준비(ready)**, **실행(running)**, **대기(waiting)**, **종료(terminated)** 등으로 분류됩니다.

3. **프로그램 카운터 (Program Counter, PC)**  
   현재 스레드가 실행 중인 명령어의 주소를 저장합니다. 스레드가 실행을 멈추고 다시 시작할 때 어디서부터 실행을 재개할지를 알기 위해 필요합니다.

4. **레지스터 (Registers)**  
   스레드가 실행 중인 상태에서 CPU 레지스터의 내용을 저장합니다. CPU에서 연산을 수행하는 동안 사용되는 다양한 데이터들이 레지스터에 저장되며, 스레드가 중단되면 해당 값을 보존해야 다음에 다시 실행할 수 있습니다.

5. **스택 포인터 (Stack Pointer)**  
   스레드마다 독립된 스택이 있기 때문에, 스레드의 스택이 어디에서 시작되는지, 현재 스택의 위치가 어디인지를 나타내는 포인터입니다. 함수 호출과 관련된 데이터를 관리합니다.

6. **우선순위 (Priority)**  
   스레드의 실행 우선순위를 나타냅니다. 스케줄러는 우선순위를 고려하여 어떤 스레드를 먼저 실행할지 결정합니다. 우선순위가 높은 스레드는 CPU 자원을 더 먼저 받을 가능성이 큽니다.

7. **스레드 소유 자원 정보 (Resource Ownership Information)**  
   스레드가 소유하고 있는 자원(파일, 메모리 등)에 대한 정보입니다. 스레드는 프로세스의 자원을 공유하지만, 특정 스레드가 잠시 독점적으로 사용할 자원에 대한 정보가 포함될 수 있습니다.

8. **스레드 관리 정보 (Thread Management Information)**  
   스케줄링과 동기화 등을 관리하기 위해 필요한 정보입니다. 스레드가 대기 중인 큐에 대한 포인터나, 잠금(Lock) 등의 동기화 정보가 이 항목에 저장됩니다.

9. **PCB와의 연결 (Link to PCB)**  
   스레드는 프로세스 내에서 실행되므로, 해당 스레드를 포함하는 프로세스 제어 블록(PCB)과 연결되어 있어야 합니다. 이를 통해 운영체제는 스레드와 프로세스를 연관 지어 관리합니다.

### TCB의 역할
- **스레드 관리**: 운영체제는 TCB를 통해 각 스레드의 상태를 추적하고, 스케줄링을 통해 적절한 시간에 스레드를 실행합니다.
- **문맥 교환(Context Switching)**: 스레드가 중단되고 다른 스레드로 전환될 때, TCB에 저장된 정보(프로그램 카운터, 레지스터, 스택 포인터 등)를 사용하여 중단된 시점의 상태를 저장하고 복원합니다.
- **동기화 및 자원 관리**: TCB는 스레드의 동기화 상태와 자원 사용 정보를 포함하므로, 여러 스레드 간의 자원 경쟁을 제어하는 데 중요한 역할을 합니다.

### TCB와 PCB의 차이
- **TCB**는 **스레드**를 관리하는 데 사용되는 데이터 구조이고, **PCB**는 **프로세스**를 관리하는 데 사용됩니다.
- 프로세스는 독립된 메모리 공간을 가지고 있지만, 스레드는 같은 프로세스 내에서 메모리와 자원을 공유하기 때문에, **TCB는 PCB와 연결**되어 있습니다.
- PCB는 프로세스 전체의 정보(파일 핸들, 메모리 맵, 프로세스 상태 등)를 포함하는 반면, TCB는 개별 스레드의 실행 상태(프로그램 카운터, 레지스터 상태 등)만을 포함합니다.

### TCB와 PCB의 연결 관계

* **하나의 프로세스는 여러 개의 TCB를 가질 수 있습니다.** 하나의 프로세스 내에서 여러 개의 쓰레드가 동시에 실행될 수 있기 때문입니다.
* **TCB는 PCB의 일부 정보를 공유합니다.** 코드 영역, 데이터 영역, 힙 영역 등 프로세스가 사용하는 자원은 일반적으로 모든 쓰레드가 공유합니다.
* **TCB는 PCB를 가리키는 포인터를 가지고 있습니다.** 각 쓰레드는 자신이 속한 프로세스의 PCB를 참조하여 필요한 정보를 얻을 수 있습니다.

**간단히 말해서, PCB는 프로세스 전체에 대한 정보를 담고 있는 큰 그림이고, TCB는 그 그림 안에서 각 쓰레드의 상세한 정보를 담고 있는 작은 조각이라고 할 수 있습니다.**

### TCB의 동작 흐름 예시

1. **스레드 생성**: 스레드가 생성되면 운영체제는 새로운 TCB를 할당하고, 초기 값(스레드 ID, 우선순위, 프로그램 카운터 등)을 설정합니다.
2. **실행 중 상태 저장**: 스레드가 실행 중인 동안, TCB는 해당 스레드의 프로그램 카운터, 레지스터 값, 스택 포인터 등의 정보를 계속 업데이트합니다.
3. **문맥 교환**: 스레드가 실행 중이던 작업을 중단하고 다른 스레드로 전환될 때, 기존 스레드의 상태를 TCB에 저장하고, 새롭게 실행될 스레드의 상태를 TCB에서 복원합니다.
4. **스레드 종료**: 스레드가 종료되면 TCB는 메모리에서 제거되고, 스레드에 할당되었던 자원이 해제됩니다.

### 요약
- **TCB**는 운영체제가 스레드를 관리하기 위해 사용하는 데이터 구조로, 스레드의 상태와 실행 정보를 저장하고 관리합니다.
- TCB는 프로그램 카운터, 레지스터, 스택 포인터와 같은 실행 정보뿐만 아니라 스레드의 ID, 우선순위 등의 정보를 포함합니다.
- TCB는 스레드 간 문맥 교환을 지원하고, 스레드가 실행되던 상태를 저장하고 복원하는 역할을 합니다.
- TCB는 PCB와 밀접하게 연결되어, 각 스레드가 속한 프로세스의 정보를 참조합니다.


## 사용자 수준 쓰레드 vs 커널 수준 쓰레드
**사용자 수준 스레드(User-Level Threads)**와 **커널 수준 스레드(Kernel-Level Threads)**는 스레드를 관리하고 실행하는 방식에 따라 구분되는 두 가지 유형입니다. 이 둘의 차이는 스레드의 관리 주체와 실행 방식에서 발생하며, 각각 장단점이 존재합니다.

### 1. 사용자 수준 스레드 (User-Level Threads, ULT)
사용자 수준 스레드는 **운영체제의 커널에 의존하지 않고**, **사용자 영역**에서 스레드의 생성과 관리가 이루어지는 스레드입니다. 즉, 스레드를 생성하고 스케줄링하는 작업이 커널이 아닌, 사용자 프로그램의 라이브러리에 의해 처리됩니다.

#### 특징
- **운영체제의 관여가 적음**: 스레드의 생성, 스케줄링, 문맥 교환 등이 모두 사용자 영역에서 수행됩니다. 커널은 이를 알지 못하므로, 커널에서는 이 스레드들을 하나의 단일 프로세스로 인식합니다.
- **빠른 스레드 관리**: 커널의 개입 없이 스레드가 관리되기 때문에 문맥 교환이 빠르며, 스레드 간의 전환이 효율적입니다. 커널 모드 전환 없이도 사용자 모드에서 스레드의 스케줄링이 가능하여 오버헤드가 적습니다.
- **다양한 스레드 라이브러리**: POSIX 스레드(Pthreads) 같은 라이브러리 등을 통해 쉽게 구현할 수 있습니다.

#### 장점
1. **문맥 교환 속도**: 커널 모드 전환이 없기 때문에 문맥 교환이 매우 빠릅니다.
2. **운영체제 독립성**: 운영체제와 상관없이 다양한 플랫폼에서 동일한 방식으로 스레드 관리가 가능합니다.
3. **유연성**: 사용자 수준에서 스케줄링 정책을 자유롭게 결정할 수 있습니다.

#### 단점
1. **멀티코어 활용 부족**: 커널이 스레드를 하나의 단일 프로세스로 인식하기 때문에, 멀티코어 시스템에서 여러 스레드를 병렬로 실행할 수 없습니다. 결국, 사용자 수준 스레드에서는 하나의 CPU만 사용됩니다.
2. **블로킹 문제**: 만약 하나의 사용자 스레드가 블로킹 I/O 작업을 수행하게 되면, 해당 프로세스의 모든 스레드가 블로킹됩니다. 커널은 모든 스레드를 단일 프로세스로 보기 때문에, 블로킹 작업을 하나의 스레드만이 수행하더라도 전체 프로세스가 중단됩니다.

#### 사용자 수준 스레드 예시
- `Pthreads (POSIX Threads)`, `Java Threads`, `Green Threads` 등이 사용자 수준 스레드를 기반으로 하는 대표적인 예시입니다.

### 2. 커널 수준 스레드 (Kernel-Level Threads, KLT)
커널 수준 스레드는 **운영체제의 커널**이 직접 스레드를 관리하는 방식입니다. 커널이 스레드의 생성, 스케줄링, 문맥 교환 등을 담당하며, 커널 수준 스레드는 커널의 지원을 받아 관리됩니다. (참고: 커널 수준 쓰레드 자체를 지원하지 않는 OS도 존재한다.)

#### 특징
- **커널에서 직접 관리**: 운영체제 커널이 스레드를 관리하며, 스레드 간의 전환이나 스케줄링 등은 커널 모드에서 이루어집니다.
- **멀티코어 활용**: 커널이 모든 스레드를 개별적으로 인식하고 관리하기 때문에, 여러 CPU 코어에서 동시에 여러 스레드를 병렬 실행할 수 있습니다.
- **커널 모드 전환**: 스레드의 생성 및 관리, 스케줄링 등이 커널에 의해 처리되므로, 커널 모드로의 전환이 필요합니다. 이로 인해 문맥 교환의 오버헤드가 사용자 수준 스레드보다 큽니다.

#### 장점
1. **병렬 처리 가능**: 커널이 스레드를 개별적으로 인식하기 때문에, 멀티코어 시스템에서 여러 스레드를 병렬로 실행할 수 있습니다.
2. **블로킹 문제 해결**: 하나의 스레드가 블로킹 작업을 하더라도 커널이 다른 스레드를 스케줄링할 수 있기 때문에, 다른 스레드들은 정상적으로 실행될 수 있습니다.
3. **I/O 작업에서 유리**: 커널이 각 스레드를 개별적으로 관리하므로, I/O 작업 중에도 나머지 스레드가 영향을 받지 않고 실행될 수 있습니다.

#### 단점
1. **높은 오버헤드**: 커널 모드 전환이 필요하기 때문에, 문맥 교환 시 오버헤드가 발생하며, 사용자 수준 스레드보다 스레드 간 전환이 느립니다.
2. **복잡한 구현**: 커널에서 스레드 관리가 이루어지므로 운영체제의 복잡성이 증가합니다.

#### 커널 수준 스레드 예시
- **Linux**의 스레드, **Windows**의 스레드, **Solaris**의 스레드가 커널 수준에서 관리되는 대표적인 예입니다.

### 3. 사용자 수준 스레드와 커널 수준 스레드 비교

| **항목**                  | **사용자 수준 스레드 (ULT)**                                | **커널 수준 스레드 (KLT)**                              |
|---------------------------|------------------------------------------------------------|---------------------------------------------------------|
| **스레드 관리 주체**       | 사용자 영역 (라이브러리)                                      | 운영체제 커널                                              |
| **문맥 교환 속도**         | 빠름 (커널 모드 전환 없음)                                      | 느림 (커널 모드 전환 필요)                                  |
| **멀티코어 활용**          | 불가능 (스레드를 하나의 단일 프로세스로 인식)                   | 가능 (각 스레드를 개별적으로 인식)                           |
| **블로킹 문제**            | 블로킹 시 전체 프로세스가 중단됨                               | 블로킹 시에도 다른 스레드는 계속 실행 가능                    |
| **사용 사례**              | POSIX Threads, Green Threads                              | Linux, Windows, Solaris Threads                          |

### 4. 혼합 스레드 모델 (Hybrid Model)
현대 운영체제에서는 **혼합 스레드 모델**을 채택하기도 합니다. 이 모델은 사용자 수준 스레드와 커널 수준 스레드의 장점을 결합한 방식으로, 사용자 수준 스레드와 커널 수준 스레드 간의 매핑을 통해 스레드를 관리합니다. 주로 **1:N**, **M:N** 모델로 불리며, 여러 사용자 수준 스레드를 하나의 커널 수준 스레드와 매핑하여 효율성을 극대화합니다.

#### 장점
- 사용자 수준 스레드의 빠른 문맥 교환과 커널 수준 스레드의 병렬 처리 능력을 동시에 제공할 수 있습니다.
- 멀티코어 시스템에서의 성능을 극대화할 수 있으며, 블로킹 문제도 해결할 수 있습니다.

#### 단점
- 복잡한 구현이 필요하며, 운영체제에 따라 지원 여부가 다를 수 있습니다.

### 요약
- **사용자 수준 스레드**는 운영체제 커널의 개입 없이 사용자 영역에서 스레드를 관리하여 빠른 성능을 제공하지만, 멀티코어 시스템에서 병렬 처리가 어렵고 블로킹 문제를 겪습니다.
- **커널 수준 스레드**는 운영체제 커널에서 스레드를 관리하여 병렬 처리와 블로킹 문제를 해결할 수 있지만, 커널 모드 전환으로 인해 성능 오버헤드가 발생할 수 있습니다.
- **혼합 모델**은 사용자 수준 스레드와 커널 수준 스레드의 장점을 결합한 방식으로, 현대 운영체제에서 널리 사용됩니다.

## 멀티 쓰레드 프로그래밍

**멀티 스레드 프로그래밍(Multi-threaded Programming)**은 하나의 프로세스 내에서 여러 스레드를 생성하여 동시에 실행시키는 방식으로, 프로그램의 성능을 개선하고 응답성을 향상시키는 기법입니다. 각 스레드는 독립적으로 실행되며, CPU의 멀티코어를 활용해 병렬 처리 능력을 극대화할 수 있습니다.

멀티 스레드 프로그래밍은 **병렬성**(parallelism)과 **동시성**(concurrency)을 효과적으로 이용하기 위한 기법으로, 프로그램의 여러 작업을 동시에 수행할 수 있도록 도와줍니다.

### 1. 멀티 스레드 프로그래밍의 필요성
멀티 스레드 프로그래밍은 주로 다음과 같은 상황에서 유용합니다:

1. **CPU 활용 극대화**: 멀티코어 CPU에서는 하나의 코어가 하나의 스레드를 실행하므로, 여러 스레드를 동시에 실행하면 CPU 자원을 최대한 활용할 수 있습니다.
2. **응답성 향상**: 사용자와 상호작용하는 프로그램은 여러 작업(예: 입력 처리, 화면 렌더링)을 동시에 처리해야 합니다. 스레드를 분리하여 처리함으로써 더 빠르게 응답할 수 있습니다.
3. **병렬 처리**: 데이터 처리를 병렬로 수행하여 대량의 데이터를 빠르게 처리할 수 있습니다. 예를 들어, 큰 데이터를 여러 스레드로 분할하여 동시에 처리하면 처리 시간을 줄일 수 있습니다.

### 2. 멀티 스레드 프로그래밍의 장점
- **병렬성**: 여러 스레드를 병렬로 실행할 수 있어 CPU의 성능을 최대한 활용할 수 있습니다.
- **응답성 개선**: 사용자 인터페이스(UI)를 유지하면서 백그라운드에서 작업을 수행할 수 있습니다. 예를 들어, UI가 멈추지 않고 파일 다운로드를 동시에 진행할 수 있습니다.
- **자원 공유**: 프로세스의 메모리와 자원을 스레드 간에 공유할 수 있어 메모리 사용량이 적고 통신이 빠릅니다.
- **단순한 자원 관리**: 프로세스 간 통신(Inter-Process Communication, IPC)에 비해 간단하게 자원을 공유하고 통신할 수 있습니다.

### 3. 멀티 스레드 프로그래밍의 단점
- **동기화 문제**: 여러 스레드가 동시에 메모리와 자원을 공유하면, **경쟁 조건(race condition)**, **교착 상태(deadlock)**, **기아 상태(starvation)** 등의 문제가 발생할 수 있습니다.
- **복잡성 증가**: 프로그램의 복잡도가 증가하여 디버깅과 테스트가 어려워집니다. 스레드 간의 비동기 작업이 예상치 못한 결과를 초래할 수 있습니다.
- **오버헤드**: 스레드를 생성하고 관리하는 데 CPU와 메모리 자원이 추가로 소모됩니다. 특히 스레드 수가 많아질수록 오버헤드가 커질 수 있습니다.

### 4. 멀티 스레드 프로그래밍 모델
멀티 스레드 프로그래밍은 여러 스레드를 실행하는 방법에 따라 여러 모델로 나눌 수 있습니다:

#### (1) **1:1 모델 (One-to-One Model)**
- **설명**: 각 사용자 수준 스레드가 하나의 커널 수준 스레드에 대응됩니다. 하나의 사용자 스레드가 생성되면, 커널에서 해당 스레드를 별도로 관리합니다.
- **장점**: 각 스레드를 커널에서 개별적으로 관리하므로, 하나의 스레드가 블로킹 상태에 빠져도 다른 스레드는 계속 실행될 수 있습니다.
- **단점**: 커널 수준 스레드를 관리하는 데 드는 오버헤드가 큽니다.

#### (2) **M:1 모델 (Many-to-One Model)**
- **설명**: 여러 사용자 수준 스레드가 하나의 커널 수준 스레드에 대응됩니다. 커널은 단일 프로세스의 일부로 스레드를 인식하며, 스레드 관리가 사용자 영역에서만 이루어집니다.
- **장점**: 커널의 개입이 적어 문맥 교환이 빠르고 오버헤드가 적습니다.
- **단점**: 하나의 스레드가 블로킹되면 전체 프로세스가 중단될 수 있으며, 멀티코어 환경에서 병렬 처리가 불가능합니다.

#### (3) **M:N 모델 (Many-to-Many Model)**
- **설명**: 여러 사용자 수준 스레드가 여러 커널 수준 스레드에 매핑됩니다. 커널과 사용자 영역 모두에서 스레드를 관리하며, 사용자가 원하는 만큼 스레드를 생성하고 커널이 병렬 실행할 수 있습니다.
- **장점**: 병렬 처리와 효율적인 자원 관리가 가능하며, 블로킹 문제도 최소화됩니다.
- **단점**: 시스템에 따라 구현과 관리가 복잡할 수 있습니다.

### 5. 멀티 스레드 프로그래밍의 주요 개념
#### (1) **경쟁 조건 (Race Condition)**
여러 스레드가 동시에 공유 자원에 접근할 때, 스레드 간의 실행 순서에 따라 결과가 달라지는 현상을 말합니다. 공유 자원을 적절히 동기화하지 않으면, 예기치 않은 결과가 발생할 수 있습니다.

#### (2) **동기화 (Synchronization)**
동기화는 여러 스레드가 **공유 자원**에 동시에 접근할 때, 충돌이나 잘못된 작업이 일어나지 않도록 **상호 배제(Mutual Exclusion)**를 보장하는 방법입니다. 대표적인 동기화 방법은 다음과 같습니다:
- **뮤텍스(Mutex)**: 하나의 스레드만 자원에 접근할 수 있도록 잠금(Lock)을 거는 방식.
- **세마포어(Semaphore)**: 한정된 자원을 여러 스레드가 사용하도록 허용하면서, 자원 접근을 제어하는 방식.
- **모니터(Monitor)**: 객체 내부에서 동기화를 자동으로 관리하는 방식.

#### (3) **문맥 교환 (Context Switching)**
여러 스레드를 실행할 때, CPU가 실행 중인 스레드를 다른 스레드로 교체하는 작업을 말합니다. 스레드의 레지스터와 프로그램 카운터 등 실행 상태를 저장하고, 새로운 스레드의 상태를 복원하는 과정을 거칩니다. 문맥 교환이 잦으면 성능에 부정적인 영향을 미칠 수 있습니다.

#### (4) **교착 상태 (Deadlock)**
여러 스레드가 서로 자원을 기다리면서, 더 이상 실행을 진행할 수 없는 상태입니다. 두 개 이상의 스레드가 서로가 가진 자원을 요구하면서 무한정 대기 상태에 빠지는 상황을 교착 상태라고 합니다.

#### (5) **기아 상태 (Starvation)**
특정 스레드가 자원을 지속적으로 얻지 못해 실행이 무한히 지연되는 상태를 말합니다. 다른 스레드가 계속해서 우선권을 가지면 기아 상태가 발생할 수 있습니다.

### 6. 멀티 스레드 프로그래밍에서의 성능 최적화
멀티 스레드 프로그래밍을 최적화하는 몇 가지 전략이 있습니다:

1. **적절한 스레드 수**: 스레드 수가 많으면 오버헤드가 발생하므로, CPU 코어 수에 맞춰 적절한 스레드 수를 설정하는 것이 중요합니다.
2. **스레드 풀(Thread Pool)**: 스레드를 미리 생성해 두고 작업을 할당하는 방식으로, 스레드 생성과 종료에 따른 오버헤드를 줄일 수 있습니다.
3. **비동기 I/O 처리**: 블로킹 I/O 작업을 비동기적으로 처리하여 스레드가 불필요하게 대기하는 시간을 줄일 수 있습니다.
4. **데이터 파티셔닝**: 데이터를 적절히 분할하여 여러 스레드가 병렬로 처리할 수 있도록 함으로써 처리 성능을 높일 수 있습니다.

### 7. 언어별 멀티 스레드 프로그래밍 지원
다양한 프로그래밍 언어에서 멀티 스레드 프로그래밍을 지원하며, 각각 고유한 방식으로 스레드를 생성하고 관리합니다.

- **Java**: `java.lang.Thread` 클래스를 사용해 스레드를 생성하고 실행할 수 있으며, `Executor` 프레임워크를 통해 스레드 풀도 지원합니다.
- **C/C++**: POSIX 스레드(Pthreads) 라이브러리를 사용해 멀티 스레드를 구현할 수 있습니다.
- **Python**: `threading` 모듈을 통해 스레드를 생성하고 관리할 수 있으며, **GIL(Global Interpreter Lock)**의 제약으로 인해 멀티스레드 CPU 병렬 처리에는 제약이 있습니다.
- **C#**: `System.Threading` 네임스페이스를 사용하여 스레드를 생성하고, `Task` 클래스를 통해 비동기 프로그래밍을 지원합니다.

### 요약
- **멀티 스레드 프로그래밍**은 여러 스레드를 병렬로 실행하여 프로그램 성능을 개선하는 기법입니다.
- 스레드는 자원을 공유하며, 동기화와 경쟁 조건, 교착 상태 등의 문제를 해결하기 위한 동기화 메커니즘이 필요합니다.
- 각 스레드 모델(1:1, M:1, M:N)은 스레드 관리 방식에 따라 장단점이 있습니다.
- 최적의 스레드 수 설정, 스레드 풀 사용, 비동기 I/O 처리를 통해 멀티 스레드 프로그래밍의 성능을 최적화할 수 있습니다.

## Thread-safe

**Thread-safe**란 여러 스레드가 동시에 하나의 공유 자원에 접근하더라도, **데이터 손상**이나 **비정상적인 동작**이 발생하지 않도록 설계된 코드를 의미합니다. 즉, 스레드 간에 안전하게 데이터를 공유하고, 동기화 문제를 방지하는 것이 thread-safe의 핵심입니다.

멀티 스레드 환경에서 **thread-safe하지 않으면**, 두 개 이상의 스레드가 동시에 동일한 자원에 접근하면서 **경쟁 조건(race condition)**이나 **데이터 손실**이 발생할 수 있습니다. 이를 막기 위해 thread-safe 코드를 작성하는 방법이 필요합니다.

### 1. Thread-safe 설계 방법

#### (1) **상호 배제(Mutual Exclusion)**
스레드가 자원을 공유할 때, 다른 스레드가 동시에 해당 자원에 접근하지 못하도록 막는 방법입니다. 주로 **락(Lock)**을 사용해 구현하며, 락을 걸어 자원에 대한 **독점적 접근**을 보장합니다.

- **뮤텍스(Mutex)**: 오직 하나의 스레드만 자원에 접근할 수 있도록 하는 잠금 장치. 락을 해제하지 않으면 다른 스레드가 자원에 접근할 수 없습니다.
  
- **모니터(Monitor)**: 객체 단위로 동기화 메커니즘을 제공하는 기능. Java와 C#에서 자주 사용되며, 객체의 임계 구역(Critical Section)을 설정해 해당 구역에 대해 스레드 간 배타적 접근을 보장합니다.

```java
// Java의 synchronized 키워드를 사용한 thread-safe 설계
public synchronized void increment() {
    count++;
}
```

- **스핀락(Spinlock)**: 락이 해제될 때까지 계속해서 자원에 접근을 시도하는 방식입니다. 짧은 시간 안에 락이 해제될 것으로 예상될 때 유용하지만, 오랜 시간 락이 걸려 있으면 성능에 문제가 생길 수 있습니다.

#### (2) **원자성(Atomicity) 보장**
하나의 작업을 더 이상 쪼갤 수 없는 단위로 만들어, 중간에 인터럽트가 발생하지 않도록 보장하는 방식입니다. **원자 연산(Atomic Operation)**은 여러 스레드가 동시에 실행해도 결과가 일관되게 유지됩니다.

- **Atomic 변수**: Java의 `java.util.concurrent.atomic` 패키지에는 `AtomicInteger`, `AtomicLong` 등 원자성을 보장하는 변수들이 제공됩니다. 이 변수들은 내부적으로 락을 걸지 않고도 동시성 문제를 해결할 수 있습니다.

```java
AtomicInteger atomicCount = new AtomicInteger(0);
atomicCount.incrementAndGet(); // 원자적으로 증가
```

#### (3) **불변 객체(Immutable Object) 사용**
불변 객체는 한 번 생성되면 내부 상태가 변하지 않는 객체로, 여러 스레드에서 동시에 읽기 작업을 해도 상태가 바뀌지 않아 thread-safe합니다. 불변 객체는 멀티스레드 환경에서 동기화 문제를 피할 수 있는 안전한 방법입니다.

- **String 객체**: 예를 들어, Java의 `String` 객체는 불변 객체로 설계되어 있기 때문에 여러 스레드에서 공유하더라도 안전합니다.

```java
String str = "immutable";  // 한 번 생성된 후 변경되지 않음
```

#### (4) **Thread-local 저장소 사용**
스레드별로 독립된 데이터를 관리하기 위한 방법으로, **Thread-local 저장소**를 사용하면 각 스레드가 다른 스레드와 독립된 변수 공간을 가질 수 있습니다. 각 스레드는 자신의 복사본을 사용하여 공유 자원에 접근하므로 동기화가 필요하지 않습니다.

- **ThreadLocal 클래스**: Java에서는 `ThreadLocal` 클래스를 통해 각 스레드가 자신만의 변수를 가질 수 있도록 설정할 수 있습니다.

```java
ThreadLocal<Integer> threadLocalVar = new ThreadLocal<>();
threadLocalVar.set(100); // 각 스레드별로 독립된 값 사용
```

#### (5) **동기화된 컬렉션 사용**
Java와 C++에서는 **동기화된 컬렉션**을 제공하여 여러 스레드가 동시에 데이터를 추가하거나 삭제해도 안전하도록 보장합니다. Java의 경우, `Collections.synchronizedList()` 같은 방법으로 동기화된 컬렉션을 사용할 수 있습니다.

```java
List<Integer> synchronizedList = Collections.synchronizedList(new ArrayList<>());
```

또한, Java의 **동시성 컬렉션(Concurrent Collections)**인 `ConcurrentHashMap`, `ConcurrentLinkedQueue` 등은 더욱 효율적으로 멀티 스레드 환경에서 안전하게 사용할 수 있습니다.

#### (6) **락 프리(lock-free) 알고리즘**
락을 사용하지 않고도 공유 자원을 안전하게 처리할 수 있는 **락 프리 알고리즘**을 사용하는 방식입니다. 이 방식은 주로 낮은 수준의 프로그래밍에서 사용되며, CPU의 원자적 연산을 활용합니다. 예를 들어 **CAS(Compare-And-Swap)**는 자원의 상태를 비교하고 조건에 맞으면 값을 교체하는 방식으로 동작합니다.

### 2. Thread-safe 설계 시 고려 사항

#### (1) **동기화 범위 최소화**
동기화된 코드의 범위가 넓어질수록 **성능 저하**가 발생할 수 있습니다. 따라서, 최소한의 범위만 동기화하여 불필요한 락 경쟁을 피하는 것이 중요합니다.

#### (2) **데드락(Deadlock) 피하기**
동기화된 코드에서 자원 순서에 따라 교착 상태가 발생할 수 있습니다. 여러 락을 사용해야 하는 상황이라면, **자원 획득 순서를 고정**하거나 **타임아웃**을 설정해 데드락을 방지해야 합니다.

#### (3) **스레드 간의 데이터 일관성 보장**
공유 데이터에 여러 스레드가 접근할 때 **일관성**을 보장하는 것도 중요합니다. 메모리 가시성 문제를 해결하기 위해 **메모리 배리어(memory barrier)**나 **volatile** 키워드를 사용해 최신 데이터를 항상 확인할 수 있도록 해야 합니다.

### 3. 언어별 Thread-safe 지원

- **Java**: `synchronized`, `volatile`, `Atomic` 클래스, `ThreadLocal`, 동시성 컬렉션 등 다양한 thread-safe 도구를 제공.
- **C/C++**: POSIX 스레드(Pthread) 라이브러리를 통해 뮤텍스, 세마포어, 원자적 연산 등 thread-safe 기능 제공.
- **Python**: `threading` 모듈에서 락(`Lock`), `RLock` 등을 제공하며, `queue.Queue` 같은 thread-safe 자료 구조도 지원.
- **C#**: `lock` 키워드로 상호 배제를 지원하며, `Monitor`, `Mutex`, `Semaphore`, `ConcurrentDictionary` 등의 도구도 사용 가능.

### 요약
- **Thread-safe**는 여러 스레드가 동시에 실행되더라도 충돌 없이 안전하게 작동하는 코드를 의미합니다.
- Thread-safe 설계 방법으로는 상호 배제(Mutex), 원자성 보장, 불변 객체 사용, Thread-local 저장소 사용, 동기화된 컬렉션 사용 등이 있습니다.
- 락을 최소화하면서 데드락과 성능 저하를 피하는 것이 중요하며, 동기화 범위를 신중히 설계해야 합니다.


## 쓰레드와 프로세스

**프로세스와 쓰레드**, 그리고 **멀티 프로세스와 멀티 스레드**는 병렬 처리를 위한 중요한 개념들이며, 각각의 차이를 명확히 이해하는 것이 성능 최적화에 필수적입니다. 이들을 비교하기 위해 **정의**, **자원 관리**, **병렬 처리** 등 다양한 측면에서 차이점을 살펴보겠습니다.

### 1. 프로세스 vs. 쓰레드

#### (1) **정의**
- **프로세스(Process)**: 운영체제에서 실행 중인 하나의 독립된 프로그램입니다. 각 프로세스는 **고유한 메모리 공간**을 할당받아 실행되며, 독립된 주소 공간을 사용합니다. 한 프로세스가 다른 프로세스의 메모리에 직접 접근할 수 없습니다.
- **쓰레드(Thread)**: 프로세스 내부에서 실행되는 **작업의 단위**입니다. 한 프로세스 내에서 여러 쓰레드가 생성될 수 있으며, 이들은 **메모리와 자원(코드, 데이터, 파일 등)을 공유**합니다. 쓰레드가 경량화된 실행 단위로 불리는 이유는 같은 프로세스 내에서 서로 자원을 공유하기 때문입니다.

#### (2) **자원 관리**
- **프로세스**: 프로세스는 **독립된 메모리 공간(주소 공간)**을 가지므로, 각 프로세스는 자체적인 자원(파일, 메모리, 환경 변수 등)을 관리합니다. 이 때문에 프로세스 간 통신(IPC: Inter-Process Communication)은 복잡합니다.
- **쓰레드**: 같은 프로세스 내의 쓰레드들은 **코드, 데이터, 파일 등의 자원을 공유**하며, 독립적인 **스택(stack)**과 **레지스터**만 갖습니다. 자원을 공유하기 때문에 쓰레드 간 통신이 훨씬 더 효율적입니다.

#### (3) **오버헤드**
- **프로세스**: 프로세스는 독립적으로 실행되기 때문에 **프로세스 생성 및 종료 시 오버헤드**가 큽니다. 또한, 각 프로세스가 별도의 메모리 공간을 가지고 있으므로 **프로세스 간 문맥 전환(Context Switch)**은 상대적으로 비용이 많이 듭니다.
- **쓰레드**: 쓰레드는 같은 프로세스 내에서 실행되므로 **쓰레드 간 문맥 전환 비용이 적고**, **메모리 관리**도 효율적입니다. 새로운 쓰레드를 생성하는 데 걸리는 오버헤드가 프로세스보다 작습니다.

#### (4) **병렬성**
- **프로세스**: 멀티 프로세스를 통해 여러 프로세스를 병렬로 실행할 수 있습니다. 그러나 각 프로세스는 독립적으로 실행되기 때문에 **메모리 사용량이 증가**할 수 있으며, 프로세스 간 통신이 복잡할 수 있습니다.
- **쓰레드**: 멀티 쓰레드는 같은 프로세스 내에서 여러 쓰레드를 병렬로 실행할 수 있습니다. **메모리 사용이 적고, 자원 공유가 용이**하지만, **동기화 문제**로 인해 데이터 경합이나 교착 상태가 발생할 수 있습니다.

#### (5) **안전성**
- **프로세스**: 하나의 프로세스에서 오류가 발생해도 다른 프로세스에 영향을 미치지 않습니다. 즉, 프로세스는 독립적이기 때문에 **안전성이 높습니다**.
- **쓰레드**: 같은 프로세스 내의 쓰레드는 메모리를 공유하기 때문에, 한 쓰레드에서 문제가 발생하면 **다른 쓰레드에도 영향을 미칠 수 있습니다**. 즉, **안전성**이 상대적으로 낮을 수 있습니다.

### 2. 멀티 프로세스 vs. 멀티 쓰레드

#### (1) **정의**
- **멀티 프로세스**: 여러 프로세스를 동시에 실행하여 작업을 병렬로 처리하는 방식입니다. 각 프로세스는 독립된 메모리 공간을 가지며, 프로세스 간 통신을 통해 협력합니다.
- **멀티 쓰레드**: 하나의 프로세스 내에서 여러 쓰레드를 동시에 실행하여 병렬 처리를 구현하는 방식입니다. 모든 쓰레드는 같은 메모리 공간을 공유하면서 독립적인 작업을 수행합니다.

#### (2) **자원 사용**
- **멀티 프로세스**: 각 프로세스는 독립된 메모리 공간을 사용하기 때문에 **메모리 사용량이 큽니다**. 프로세스 간 통신을 위해서는 **IPC 기법**(파이프, 소켓, 메시지 큐 등)을 사용해야 합니다.
- **멀티 쓰레드**: 쓰레드는 같은 프로세스의 메모리 자원을 공유하므로 **메모리 사용이 효율적**입니다. 쓰레드 간 데이터 공유도 직접적으로 이루어질 수 있어 **프로세스 간 통신보다 빠릅니다**.

#### (3) **문맥 전환 비용**
- **멀티 프로세스**: 각 프로세스는 독립적인 메모리 공간과 자원을 사용하므로, **문맥 전환 비용이 큽니다**. 문맥 전환 시마다 프로세스의 모든 상태(레지스터, 메모리, 파일 핸들 등)를 저장하고 불러와야 하기 때문에 성능 저하가 발생할 수 있습니다.
- **멀티 쓰레드**: 쓰레드는 같은 메모리 공간을 공유하기 때문에, **문맥 전환 비용이 상대적으로 적습니다**. 프로세스 간 문맥 전환보다 훨씬 빠르게 작업을 처리할 수 있습니다.

#### (4) **안정성 및 오류 처리**
- **멀티 프로세스**: 각 프로세스는 독립적으로 실행되므로, 한 프로세스에서 오류가 발생해도 다른 프로세스에 영향을 주지 않습니다. 즉, **안정성**이 높고, **격리성**이 좋습니다.
- **멀티 쓰레드**: 쓰레드는 같은 메모리를 공유하기 때문에 **한 쓰레드에서 발생한 오류가 다른 쓰레드에도 영향을 미칠 수 있습니다**. 특히, 동기화 문제가 발생하면 **경쟁 조건, 데드락** 등의 위험이 큽니다.

#### (5) **복잡성**
- **멀티 프로세스**: 멀티 프로세스는 프로세스 간 통신을 위해 **IPC 기법**을 사용해야 하므로, **복잡성**이 증가할 수 있습니다. 또한, 프로세스 간 자원 공유가 어렵기 때문에 성능 최적화가 복잡합니다.
- **멀티 쓰레드**: 쓰레드는 메모리와 자원을 공유하므로 **자원 공유가 용이**하고, 프로그래밍 복잡성이 덜할 수 있습니다. 하지만, 쓰레드 동기화와 관련된 문제를 해결해야 하므로 **동기화 작업이 필요**하며, 이는 복잡성을 증가시킬 수 있습니다.

### 3. 사용 사례 비교

#### (1) **멀티 프로세스 사용 사례**
- **웹 서버**: 멀티 프로세스를 사용하는 대표적인 예로 **Apache 웹 서버**가 있습니다. Apache는 각 클라이언트 요청을 별도의 프로세스로 처리하여 안정성을 보장합니다.
- **보안이 중요한 환경**: 각 프로세스가 독립적으로 실행되므로, 프로세스 간의 격리로 인해 보안이 중요한 환경에서 유리합니다. 예를 들어, **크롬 브라우저**는 각 탭을 독립된 프로세스로 실행하여 한 탭의 오류가 다른 탭에 영향을 미치지 않도록 설계되어 있습니다.

#### (2) **멀티 쓰레드 사용 사례**
- **웹 애플리케이션 서버**: **Java의 Tomcat**과 같은 웹 애플리케이션 서버는 멀티 쓰레드를 사용하여 동시에 여러 요청을 처리합니다. 이는 성능과 자원 사용의 효율성을 극대화하기 위한 방식입니다.
- **게임 엔진**: 게임 엔진에서는 **물리 연산, 렌더링, AI** 등의 다양한 작업을 동시에 처리해야 하므로 멀티 쓰레드 구조가 자주 사용됩니다. 이러한 작업들은 서로 독립적이지만, 자원 공유가 필요하기 때문에 멀티 쓰레드 구조가 적합합니다.

### 요약

| **항목**              | **프로세스**                            | **쓰레드**                         | **멀티 프로세스**                      | **멀티 쓰레드**                          |
|-------------------|-------------------------------------|---------------------------------|--------------------------------|------------------------------------|
| **정의**              | 독립된 실행 단위                         | 프로세스 내의 실행 단위               | 여러 프로세스를 병렬 실행               | 하나의 프로세스 내에서 여러 쓰레드를 병렬 실행 |
| **메모리 관리**       | 각 프로세스는 고유한 메모리 공간 사용            | 같은 프로세스 내에서 메모리 공유          | 각 프로세스가 독립된 메모리 공간 사용       | 메모리와 자원을 공유                       |
| **오버헤드**          | 프로세스 생성 및 종료 비용이 큼                | 쓰레드 생성 비용이 작음                 | 문맥 전환 비용이 큼                   | 문맥 전환 비용이 작음                     |
| **자원 공유**         | 자원 공유가 어려움                         | 자원 공유가 용이                     | IPC를 통한 통신 필요                   | 메모리와 자원 직접 공유 가능               |
| **안전성**            | 프로세스 간 오류 격리                       | 같은 프로세스 내 오류가 다른 쓰레드에 영향 | 하나의 프로세스 오류가 다른 프로세스에 영향 없음 | 한 쓰레드의 오류가 전체 프로세스에 영향     |
| **병렬성**            | 여러 프로세스를 병렬로 실행 가능                | 여러 쓰레드를 병렬로 실행 가능            | 각 프로세스가 독립적으로 실행됨            | 쓰레드 간 자원 공유로 성능이 향상될 수 있음  |
