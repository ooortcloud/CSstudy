## 프로그램과 프로세스

**프로그램**과 **프로세스**는 컴퓨터 시스템에서 자주 등장하는 개념이지만, 혼동하기 쉽습니다. 간단히 말해서, **프로그램**은 정적인 코드의 집합체이고, **프로세스**는 그 코드가 실제로 실행되고 있는 동적인 상태를 의미합니다.

### 프로그램 (Program)

* **정적인 상태:** 디스크에 저장되어 있는 실행 가능한 파일입니다.
* **코드의 집합:** 컴퓨터에게 어떤 작업을 수행하도록 지시하는 명령어들의 모음입니다.
* **예시:** 워드프로세서 프로그램, 웹 브라우저 프로그램, 게임 프로그램 등

### 프로세스 (Process)

* **동적인 상태:** 프로그램이 메모리에 로드되어 실행 중인 상태입니다.
* **시스템 자원 할당:** 운영체제로부터 CPU 시간, 메모리, 파일 등의 시스템 자원을 할당받아 작업을 수행합니다.
* **독립적인 실행 단위:** 각 프로세스는 다른 프로세스와 독립적으로 실행되며, 자체적인 메모리 공간과 실행 흐름을 가집니다.
* **예시:** 실행 중인 워드 문서, 열려 있는 웹 페이지, 게임 화면

### 프로그램과 프로세스의 관계

* **일대다 관계:** 하나의 프로그램은 여러 개의 프로세스를 생성할 수 있습니다. 예를 들어, 웹 브라우저 프로그램 하나를 열어 여러 개의 탭을 켜면 각 탭은 별개의 프로세스로 동작합니다.
* **프로그램 실행:** 프로그램이 실행되면 운영체제는 해당 프로그램을 메모리에 로드하고 새로운 프로세스를 생성합니다.

## 프로세스 자세히 알아보기

**프로세스**는 컴퓨터에서 실행 중인 프로그램을 의미하며, 실행되는 동안 필요한 모든 자원과 데이터를 포함한 독립적인 작업 단위입니다. 운영체제는 여러 프로세스를 관리하며, 각 프로세스는 운영체제 내에서 자원을 할당받고, 메모리와 CPU 등의 자원을 사용하여 작업을 수행합니다.

### 프로세스 문맥(Process Context)

멀티태스킹을 구현하기 위해서는 이전에 어디까지 명령을 수행했는지 정확한 수행 시점과 그때의 상태를 백업해둘 방안이 필요하다. 그 정보들이 `프로세스 문맥`이다.

#### 프로세스 문맥 구성 요소
1. **하드웨어 문맥 (Hardware Context)**
   - **프로그램 카운터 (Program Counter):** 현재 실행 중인 명령어의 위치를 가리킵니다.
   - **레지스터 (Registers):** 프로세스가 실행 중에 사용하고 있는 데이터들이 저장됩니다.

2. **프로세스 주소 공간 (Process Address Space)**
   - **코드 영역 (Code Segment):** 실행할 프로그램 코드가 저장된 메모리 공간입니다.
   - **데이터 영역 (Data Segment):** 전역 변수와 같은 데이터가 저장된 공간입니다.
   - **스택 영역 (Stack Segment):** 함수 호출 시의 지역 변수 및 호출 정보를 저장하는 공간입니다.

3. **프로세스 관련 커널 자료 구조**
   - **프로세스 제어 블록 (PCB, Process Control Block):** 운영체제가 각 프로세스를 관리하기 위해 사용하는 데이터 구조로, 프로세스 상태, ID, 스케줄링 정보, 메모리 위치 정보 등이 포함됩니다.

이러한 정보들은 프로세스가 CPU에서 실행될 때 필요한 모든 상태 정보를 포함하며, 문맥 교환 시에 저장되고 복원됩니다. 이를 통해 CPU는 여러 프로세스를 번갈아 가며 효율적으로 처리할 수 있습니다.


#### 프로세스의 메모리 공간

위 프로세스 문맥 구성 요소 중 `프로세스 주소 공간`의 구조에 대해 상세히 알아보자.

<p align="center">
  <img src="../이미지%20폴더/프로세스%20구조.png">
</p>

위 이미지 기준 위에서 아래로 주소값이 점점 증가하는 형태이다.

- **코드 섹션 (Text Section)**: 프로그램의 실행 명령어가 저장되어 있는 공간입니다. 컴파일된 프로그램의 명령어들이 여기에 위치하며, CPU가 이 명령어들을 차례대로 실행합니다. Read-only.
- **데이터 섹션 (Data Section)**: 런타임 이전에 초기화된 전역 변수 및 정적(static) 변수가 저장되는 공간이다.
- **BSS(Block Started by Symbol)**: 런타임 이후에 초기화할 전역변수 및 정적 변수가 저장되는 공간이다. ROM의 메모리 공간을 절약하기 위해 등장한 공간이다.
- **힙 (Heap)**: 동적으로 할당된 메모리가 저장되는 공간입니다. 런타임에 크기가 변하는 데이터 구조(예: 동적 배열)가 이 영역에서 할당됩니다.
- **스택 (Stack)**: 함수 호출 시 지역 변수와 리턴 주소 등을 저장하는 공간입니다. 함수가 호출될 때마다 스택 프레임이 생성되고, 함수가 끝나면 스택에서 제거됩니다.

#### 프로세스 제어 블록 (PCB)

운영체제는 프로세스를 관리하기 위해 각 프로세스마다 정보를 저장하는 자료구조인 **프로세스 제어 블록(PCB)**를 사용한다. PCB에는 `프로세스 문맥` 정보들이 저장되어 있다.

<p align="center">
  <img src="../이미지%20폴더/PCB.png"  width="50%" height="50%">
</p>

- **프로세스 ID**: 각 프로세스에 할당된 고유 식별자입니다.
- **프로세스 상태**: 해당 프로세스가 New, Ready, Running, Waiting, Terminated 중 어느 상태에 있는지 나타냅니다.
- **프로그램 카운터**: 다음에 실행할 명령어의 주소를 저장합니다.
- **레지스터 값**: 프로세스가 사용 중인 CPU 레지스터의 값입니다. 프로세스가 중단될 경우 이 값이 PCB에 저장됩니다.
- **메모리 관리 정보**: 프로세스가 사용하는 메모리 영역의 시작 주소와 크기 정보입니다.
- **CPU 스케줄링 정보**: 프로세스의 우선순위, 할당된 시간, 대기 시간 등의 스케줄링 정보를 포함합니다.

[더 자세한 내용](./세부%20개념/프로세스%20제어%20블록.md)


### 프로세스의 상태

프로세스는 실행 중에 다양한 상태를 거치며, 그 상태는 운영체제가 관리합니다. 주요 프로세스 상태는 다음과 같습니다:

<p align="center">
  <img src="../이미지%20폴더/프로세스%20상태.png">
</p>

- **New**: 프로세스에 메모리를 할당 중인 상태이다.(프로세스 생성 중)
- **Ready**: 프로세스가 완전히 생성된 이후 실행 대기 중인 상태이다. 다른 프로세스가 점유 중인 CPU가 사용 가능해질 때까지 기다린다. 여러 프로세스가 준비 상태로 대기하며, 스케줄러가 다음에 실행할 프로세스를 선택한다.
- **Running**: 프로세스가 현재 CPU를 할당받아 실행 중인 상태이다.
- **Waiting (Blocked)**: 실행 중이던 프로세스가 특정 이벤트(예: 입출력 작업, 자원 할당 등)가 완료되기를 기다리는 상태이다.
- **Terminated**: 프로세스가 정상적으로 종료되었거나, 오류로 인해 더 이상 실행되지 않는 상태이다.

> CPU 스켸줄러 또는 인터럽트에 의해 프로세스가 전환될 때마다 [문맥 전환](./세부%20개념/문맥%20전환.md)이 발생한다.


## 멀티 프로세스
**멀티 프로세스(Multi-process)**는 하나의 컴퓨터에서 여러 개의 프로세스를 메모리 위에 올려두어 작업을 처리하는 방식이다. 각 프로세스가 독립된 메모리 공간을 가지며, 운영체제가 이들을 스케줄링하여 CPU 시간을 할당한다. 이러한 구조는 안정성과 확장성 면에서 유리하며, 다양한 운영체제에서 널리 사용된다. 다만 프로세스를 전환할 때마다 문맥 교환이 발생하는 오버헤드를 고려하여 설계해야 한다.

각 프로세스는 고유의 메모리 공간과 자원을 가지고 독립적으로 실행되므로 프로세스끼리 직접적인 메모리 공유는 하지 않지만, **프로세스 간 통신(IPC, Inter-Process Communication)**을 통해 데이터를 주고받을 수 있습니다.

### 주요 특징:
- **독립성**: 각 프로세스는 다른 프로세스와 별도의 메모리 공간을 사용하기 때문에 한 프로세스의 오류가 다른 프로세스에 영향을 미치지 않습니다.
- **병렬 처리**: 여러 프로세스가 동시에 실행되면서 CPU의 여러 코어를 효율적으로 활용합니다. 각 코어가 하나의 프로세스를 처리할 수 있어 멀티코어 시스템에서 성능이 크게 향상됩니다.(싱글 코어는 해당 안됨.)
- **프로세스 간 통신 필요**: 프로세스가 서로 독립적이기 때문에, 데이터나 상태를 공유하려면 특정 통신 메커니즘(예: 파이프, 소켓, 메시지 큐)을 사용해야 합니다.

### 멀티 프로세스의 장점

1. **안정성**: 프로세스가 독립적으로 실행되기 때문에, 하나의 프로세스가 비정상적으로 종료되거나 문제가 생겨도 다른 프로세스에는 영향을 미치지 않습니다. 이로 인해 시스템의 안정성이 향상됩니다.
2. **메모리 보호**: 각 프로세스는 독립된 메모리 공간을 가지고 있어, 다른 프로세스의 메모리를 침범하거나 데이터 충돌이 발생할 가능성이 적습니다.
3. **병렬성 활용**: 멀티코어 시스템에서는 각 프로세스가 다른 코어에서 동시에 실행될 수 있으므로 CPU 자원을 최대로 활용하여 병렬 처리를 극대화할 수 있습니다.(싱글 코어는 해당 안됨.)

### 멀티 프로세스의 단점

1. **오버헤드**: 프로세스 간 독립성을 유지하기 위해, 프로세스가 생성되거나 종료될 때 많은 시스템 자원이 사용됩니다. 특히, 프로세스 간 데이터 교환 시 복잡한 통신 방식이 필요하며, 그로 인해 성능 저하가 발생할 수 있습니다.
2. **프로세스 간 통신의 복잡성**: 멀티 프로세스 환경에서는 데이터 공유가 직접적으로 불가능하므로, IPC 메커니즘을 통해 데이터를 주고받아야 합니다. 이 과정은 복잡하고 성능에 부정적인 영향을 미칠 수 있습니다.
3. **메모리 사용량 증가**: 각 프로세스가 독립된 메모리 공간을 사용하기 때문에 메모리 사용량이 많아집니다. 대규모 멀티 프로세스를 사용하는 경우, 메모리 자원이 빨리 고갈될 수 있습니다.

### 멀티 프로세스의 활용 사례

#### 웹 서버
웹 서버는 다중 사용자의 요청을 처리할 때 멀티 프로세스를 사용합니다. 각 클라이언트의 요청은 별도의 프로세스로 처리되며, 이를 통해 서버는 병렬로 여러 요청을 처리할 수 있습니다. 예를 들어, **Apache** 웹 서버는 새로운 클라이언트 요청이 들어올 때마다 새로운 프로세스를 생성하여 요청을 처리합니다.(하지만 이로 인해 메모리 부담이 크다는 단점이 있다.)

#### 데이터베이스 서버
데이터베이스 서버도 멀티 프로세스를 사용하여 여러 클라이언트의 질의(query)를 동시에 처리합니다. **PostgreSQL** 같은 데이터베이스 시스템은 클라이언트의 질의를 각기 다른 프로세스로 처리하여 성능을 높이고, 장애가 발생하더라도 다른 프로세스에 영향을 주지 않도록 합니다.

#### 컴파일러
컴파일러는 코드를 컴파일할 때 여러 프로세스를 동시에 사용하여 코드의 여러 부분을 병렬로 처리할 수 있습니다. 특히 대규모 프로젝트에서는 파일 단위로 병렬 컴파일을 수행하여 컴파일 시간을 크게 줄일 수 있습니다.

### 프로세스 간 통신 (IPC)

프로세스는 독립적이지만, 여러 프로세스가 협력 작업을 할 때는 서로 데이터를 주고받아야 합니다. 이를 **프로세스 간 통신(IPC, Inter-Process Communication)**이라고 합니다. IPC의 주요 방식은 다음과 같습니다:

- **파이프 (Pipes)**: 하나의 프로세스가 다른 프로세스에 데이터를 전송할 수 있는 단방향 데이터 흐름 통로이다. 파이프 두 개를 설치해 양방향 형태로 구현 가능하다.
- **메시지 큐 (Message Queues)**: 프로세스 간에 메시지를 주고받을 수 있도록 해주는 큐 자료구조의 데이터 전송 방법이다. 비동기 통신 시스템에서 자주 쓰인다.
- **공유 메모리 (Shared Memory)**: 프로세스 간에 메모리 영역을 공유하여 데이터를 주고받는 방식이다. 가장 빠른 통신 방법이지만, 동기화 문제가 발생할 수 있다는 단점이 있다.
- **소켓 (Sockets)**: 네트워크를 통해 다른 프로세스와 데이터를 주고받을 때 사용한다.

[더 자세한 내용](./세부%20개념/IPC.md)

### 프로세스 생성과 종료

#### 프로세스 생성
프로세스는 다른 프로세스에 의해 생성될 수 있습니다. 운영체제는 부모 프로세스가 자식 프로세스를 생성하는 형태로 동작하며, 자식 프로세스는 부모 프로세스의 일부 자원을 상속받습니다.

- **`fork()` 시스템 호출**: Unix 기반 운영체제에서는 `fork()` 호출을 통해 새로운 프로세스가 생성된다. 이 함수를 호출한 부모 프로세스는 자식 프로세스의 ID를 반환받으며, 자식 프로세스는 부모 프로세스의 복사본으로 생성된다. [더 자세한 내용](./세부%20개념/fork함수.md)
- **`exec()` 시스템 호출**: 자식 프로세스에서 `exec()` 시스템 호출하면, 자식 프로세스의 메모리에서 부모 프로세스로부터 복사한 정보를 모두 지우고 새롭게 로드하여 실행된다. [더 자세한 내용](./세부%20개념/exec함수.md)

#### 프로세스 종료
프로세스는 작업을 완료하거나 강제로 종료될 수 있습니다.

- **정상 종료**: 프로세스가 실행을 완료하고 `exit()` 시스템 호출을 통해 종료됩니다. 이때 모든 자원이 운영체제로 반환됩니다.
- **비정상 종료**: 프로세스가 오류를 만나거나 부모 프로세스에 의해 강제 종료될 경우 발생합니다. 자식 프로세스는 부모 프로세스에 종료 상태를 보고하고 모든 자원을 해제합니다.
