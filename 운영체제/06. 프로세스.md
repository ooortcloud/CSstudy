## 프로그램과 프로세스

**프로그램**과 **프로세스**는 컴퓨터 시스템에서 자주 등장하는 개념이지만, 혼동하기 쉽습니다. 간단히 말해서, **프로그램**은 정적인 코드의 집합체이고, **프로세스**는 그 코드가 실제로 실행되고 있는 동적인 상태를 의미합니다.

### 프로그램 (Program)

* **정적인 상태:** 디스크에 저장되어 있는 실행 가능한 파일입니다.
* **코드의 집합:** 컴퓨터에게 어떤 작업을 수행하도록 지시하는 명령어들의 모음입니다.
* **예시:** 워드프로세서 프로그램, 웹 브라우저 프로그램, 게임 프로그램 등

### 프로세스 (Process)

* **동적인 상태:** 프로그램이 메모리에 로드되어 실행 중인 상태입니다.
* **시스템 자원 할당:** 운영체제로부터 CPU 시간, 메모리, 파일 등의 시스템 자원을 할당받아 작업을 수행합니다.
* **독립적인 실행 단위:** 각 프로세스는 다른 프로세스와 독립적으로 실행되며, 자체적인 메모리 공간과 실행 흐름을 가집니다.
* **예시:** 실행 중인 워드 문서, 열려 있는 웹 페이지, 게임 화면

### 프로그램과 프로세스의 관계

* **일대다 관계:** 하나의 프로그램은 여러 개의 프로세스를 생성할 수 있습니다. 예를 들어, 웹 브라우저 프로그램 하나를 열어 여러 개의 탭을 켜면 각 탭은 별개의 프로세스로 동작합니다.
* **프로그램 실행:** 프로그램이 실행되면 운영체제는 해당 프로그램을 메모리에 로드하고 새로운 프로세스를 생성합니다.

### 쉽게 이해하기 위한 비유

* **프로그램:** 요리 레시피 (정적인 정보)
* **프로세스:** 실제 요리를 하는 행위 (동적인 과정)

요리 레시피는 그 자체로 요리가 아니지만, 레시피를 보고 요리를 할 때 비로소 요리가 완성되는 것처럼, 프로그램은 그 자체로 실행되는 것이 아니라 프로세스를 통해 실행됩니다.

### 왜 프로그램과 프로세스를 구분해야 할까요?

* **운영체제의 효율적인 관리:** 운영체제는 프로세스를 관리하여 다양한 프로그램을 동시에 실행하고, 시스템 자원을 효율적으로 활용합니다.
* **멀티태스킹:** 여러 개의 프로세스를 번갈아 가며 실행하여 사용자에게 동시에 여러 작업을 수행하는 것처럼 보이게 합니다.
* **프로그램 오류 처리:** 각 프로세스는 독립적인 메모리 공간을 가지므로, 하나의 프로세스에 문제가 발생하더라도 다른 프로세스에 영향을 미치지 않도록 보호합니다.

**결론적으로,** 프로그램은 실행 가능한 코드의 집합체이고, 프로세스는 그 코드가 실제로 실행되고 있는 동적인 상태입니다. 이 두 개념을 정확히 이해하는 것은 컴퓨터 시스템의 작동 원리를 파악하는 데 필수적입니다.

## 프로세스 자세히 알아보기

**프로세스**는 컴퓨터에서 실행 중인 프로그램을 의미하며, 실행되는 동안 필요한 모든 자원과 데이터를 포함한 독립적인 작업 단위입니다. 운영체제는 여러 프로세스를 관리하며, 각 프로세스는 운영체제 내에서 자원을 할당받고, 메모리와 CPU 등의 자원을 사용하여 작업을 수행합니다. 프로세스는 운영체제가 시스템 자원을 효율적으로 관리하기 위한 핵심 개념입니다.

### 1. 프로세스의 구성 요소

프로세스는 단순히 코드만이 아니라, 프로그램이 실행되는 동안 필요한 다양한 정보와 자원을 포함합니다. 주요 구성 요소는 다음과 같습니다.

<p align="center">
  <img src="../이미지%20폴더/프로세스%20구조.png">
</p>

- **코드 섹션 (Text Section)**: 프로그램의 실행 명령어가 저장되어 있는 공간입니다. 컴파일된 프로그램의 명령어들이 여기에 위치하며, CPU가 이 명령어들을 차례대로 실행합니다. Read-only.
- **데이터 섹션 (Data Section)**: 전역 변수 및 초기화된 변수(정적(static) 변수)가 저장되는 공간입니다.
- **힙 (Heap)**: 동적으로 할당된 메모리가 저장되는 공간입니다. 런타임에 크기가 변하는 데이터 구조(예: 동적 배열)가 이 영역에서 할당됩니다.
- **스택 (Stack)**: 함수 호출 시 지역 변수와 리턴 주소 등을 저장하는 공간입니다. 함수가 호출될 때마다 스택 프레임이 생성되고, 함수가 끝나면 스택에서 제거됩니다.
- **프로세스 제어 블록 (PCB, Process Control Block)**: 프로세스에 대한 메타데이터를 저장하는 자료 구조입니다. 운영체제는 이 정보를 사용하여 프로세스를 관리합니다.

### 2. 프로세스의 상태

프로세스는 실행 중에 다양한 상태를 거치며, 그 상태는 운영체제가 관리합니다. 주요 프로세스 상태는 다음과 같습니다:

<p align="center">
  <img src="../이미지%20폴더/프로세스%20상태.png">
</p>

- **New**: 프로세스가 생성 중인 상태입니다. 아직 메모리 할당이 완료되지 않았으며, 준비 단계에 있습니다.
- **Ready**: 실행 대기 중인 상태로, 프로세스는 실행될 준비가 되어 있으나 CPU가 사용 가능해지기를 기다리고 있습니다. 여러 프로세스가 준비 상태로 대기하며, 스케줄러가 다음에 실행할 프로세스를 선택합니다.
- **Running**: 현재 CPU를 할당받아 실행 중인 상태입니다.
- **Waiting (Blocked)**: 실행 중이던 프로세스가 특정 이벤트(예: 입출력 작업, 자원 할당 등)가 완료되기를 기다리는 상태입니다.
- **Terminated**: 프로세스가 정상적으로 종료되었거나, 오류로 인해 더 이상 실행되지 않는 상태입니다.

**프로세스 상태 변화 예시**
1. 생성 → 준비: 프로그램이 실행되면 생성 상태에서 준비 상태로 이동합니다.
2. 준비 → 실행: 스케줄러가 해당 프로세스를 선택하면 실행 상태로 이동합니다.
3. 실행 → 준비: 시간 할당이 끝나거나 다른 프로세스에게 CPU를 넘겨줄 때 준비 상태로 돌아갑니다.
4. 실행 → 대기: 입출력 작업을 요청하거나 자원을 요청할 때 대기 상태로 이동합니다.
5. 대기 → 준비: 요청한 이벤트가 발생하면 다시 준비 상태로 이동합니다.

> CPU 스켸줄러 또는 인터럽트에 의해 프로세스가 전환될 때 [문맥 전환](./세부%20개념/문맥%20전환.md)이 발생한다.

### 3. 프로세스 제어 블록 (PCB)

운영체제가 프로세스를 관리하기 위해 각 프로세스마다 정보를 저장하는 구조체인 **프로세스 제어 블록(PCB)**를 사용합니다. PCB는 운영체제의 중요한 데이터 구조로, 프로세스의 상태, 할당된 자원, 메모리 정보 등을 포함하고 있습니다. PCB에 포함된 정보는 `프로세스 문맥`이라고 부르며, 그 요소들은 다음과 같습니다.

<p align="center">
  <img src="../이미지%20폴더/PCB.png"  width="50%" height="50%">
</p>

- **프로세스 ID**: 각 프로세스에 할당된 고유 식별자입니다.
- **프로세스 상태**: 해당 프로세스가 New, Ready, Running, Waiting, Terminated 중 어느 상태에 있는지 나타냅니다.
- **프로그램 카운터**: 다음에 실행할 명령어의 주소를 저장합니다.
- **레지스터 값**: 프로세스가 사용 중인 CPU 레지스터의 값입니다. 프로세스가 중단될 경우 이 값이 PCB에 저장됩니다.
- **메모리 관리 정보**: 프로세스가 사용하는 메모리 영역의 시작 주소와 크기 정보입니다.
- **CPU 스케줄링 정보**: 프로세스의 우선순위, 할당된 시간, 대기 시간 등의 스케줄링 정보를 포함합니다.

[더 자세한 내용](./세부%20개념/프로세스%20제어%20블록.md)

### 4. 프로세스 생성과 종료

#### 프로세스 생성
프로세스는 다른 프로세스에 의해 생성될 수 있습니다. 운영체제는 부모 프로세스가 자식 프로세스를 생성하는 형태로 동작하며, 자식 프로세스는 부모 프로세스의 일부 자원을 상속받습니다.

- **`fork()` 시스템 호출**: Unix 기반 운영체제에서 `fork()` 호출을 통해 새로운 프로세스가 생성됩니다. 부모 프로세스는 자식 프로세스의 ID를 반환받으며, 자식 프로세스는 부모 프로세스의 복사본으로 생성됩니다. [더 자세한 내용](./세부%20개념/fork함수.md)
- **`exec()` 시스템 호출**: 새로운 프로세스가 생성된 후, `exec()` 시스템 호출을 통해 자식 프로세스의 메모리에 새로운 프로그램이 로드되어 실행됩니다. [더 자세한 내용](./세부%20개념/exec함수.md)

#### 프로세스 종료
프로세스는 작업을 완료하거나 강제로 종료될 수 있습니다.

- **정상 종료**: 프로세스가 실행을 완료하고 `exit()` 시스템 호출을 통해 종료됩니다. 이때 모든 자원이 운영체제로 반환됩니다.
- **비정상 종료**: 프로세스가 오류를 만나거나 부모 프로세스에 의해 강제 종료될 경우 발생합니다. 자식 프로세스는 부모 프로세스에 종료 상태를 보고하고 모든 자원을 해제합니다.

### 5. 프로세스 스케줄링

운영체제는 여러 프로세스를 효율적으로 관리하기 위해 **스케줄링 알고리즘**을 사용하여 CPU 시간을 할당합니다. 스케줄링 알고리즘은 프로세스가 효율적으로 실행되도록 CPU 사용을 제어하며, 다음과 같은 방식으로 구분됩니다:

- **비선점형 스케줄링**: 프로세스가 한 번 CPU를 할당받으면 자발적으로 종료하거나 입출력 대기로 전환되기 전까지 CPU를 계속 사용합니다. (예: FIFO, SJF)
- **선점형 스케줄링**: 프로세스는 CPU 사용 중에 더 높은 우선순위의 프로세스가 들어오면 CPU를 뺏길 수 있습니다. (예: 라운드 로빈, 우선순위 스케줄링)

### 6. 프로세스 간 통신 (IPC)

프로세스는 독립적이지만, 여러 프로세스가 협력 작업을 할 때는 서로 데이터를 주고받아야 합니다. 이를 **프로세스 간 통신(IPC, Inter-Process Communication)**이라고 합니다. IPC의 주요 방식은 다음과 같습니다:

- **파이프 (Pipes)**: 하나의 프로세스가 다른 프로세스에 데이터를 전송할 수 있는 일종의 데이터 흐름 통로입니다.
- **메시지 큐 (Message Queues)**: 메시지 큐는 프로세스가 메시지를 주고받을 수 있도록 해주는 큐 구조의 데이터 전송 방법입니다.
- **공유 메모리 (Shared Memory)**: 프로세스 간에 메모리 영역을 공유하여 데이터를 주고받는 방식입니다. 가장 빠른 통신 방법이지만 동기화 문제가 발생할 수 있습니다.
- **소켓 (Sockets)**: 네트워크를 통해 다른 프로세스와 데이터를 주고받을 때 사용됩니다.

[더 자세한 내용](./세부%20개념/IPC.md)

### 7. 프로세스와 스레드의 차이

프로세스와 스레드는 기본적으로 작업 단위라는 점에서는 유사하지만, 다음과 같은 차이가 있습니다:

- **프로세스**: 각각 독립된 메모리 공간을 사용하며, 각 프로세스는 서로 격리되어 있습니다.
- **스레드**: 하나의 프로세스 내에서 실행되며, 같은 메모리 공간을 공유합니다. 스레드는 서로 간의 자원 접근이 빠르지만, 동기화 문제가 발생할 수 있습니다.

### 8. 프로세스의 중요성

프로세스는 운영체제가 시스템 자원을 효율적으로 관리하고, 여러 작업을 동시에 처리할 수 있게 해주는 핵심 요소입니다. 현대의 멀티태스킹 시스템에서는 수많은 프로세스가 동시에 실행되며, 운영체제가 이 프로세스들을 관리하고 조율합니다. 각 프로세스는 독립적으로 실행되지만, 시스템 자원을 경쟁하기 때문에 운영체제가 적절히 자원을 배분하고 조정하는 것이 매우 중요합니다.


## 멀티 프로세스
**멀티 프로세스(Multi-process)**는 하나의 컴퓨터에서 여러 개의 프로세스를 동시에 실행하여 작업을 병렬로 처리하는 방식입니다. 멀티 프로세스는 각 프로세스가 독립된 메모리 공간을 가지며, 운영체제가 이들을 스케줄링하여 CPU 시간을 할당합니다. 이러한 구조는 안정성과 확장성 면에서 유리하며, 다양한 운영체제에서 널리 사용됩니다. 프로세스를 전환할 때마다 문맥 교환이 발생하는 오버헤드를 고려하여 설계해야 한다.

### 1. 멀티 프로세스의 개념

멀티 프로세스는 **다중 작업을 동시에 수행**하는 방식으로, 각 프로세스는 고유의 메모리 공간과 자원을 가지고 독립적으로 실행됩니다. 프로세스끼리 직접적인 메모리 공유는 하지 않지만, **프로세스 간 통신(IPC, Inter-Process Communication)**을 통해 데이터를 주고받을 수 있습니다.

#### 주요 특징:
- **독립성**: 각 프로세스는 다른 프로세스와 별도의 메모리 공간을 사용하기 때문에 한 프로세스의 오류가 다른 프로세스에 영향을 미치지 않습니다.
- **병렬 처리**: 여러 프로세스가 동시에 실행되면서 CPU의 여러 코어를 효율적으로 활용합니다. 각 코어가 하나의 프로세스를 처리할 수 있어 멀티코어 시스템에서 성능이 크게 향상됩니다.
- **프로세스 간 통신 필요**: 프로세스가 서로 독립적이기 때문에, 데이터나 상태를 공유하려면 특정 통신 메커니즘(예: 파이프, 소켓, 메시지 큐)을 사용해야 합니다.

### 2. 멀티 프로세스의 장점

1. **안정성**: 프로세스가 독립적으로 실행되기 때문에, 하나의 프로세스가 비정상적으로 종료되거나 문제가 생겨도 다른 프로세스에는 영향을 미치지 않습니다. 이로 인해 시스템의 안정성이 향상됩니다.
2. **메모리 보호**: 각 프로세스는 독립된 메모리 공간을 가지고 있어, 다른 프로세스의 메모리를 침범하거나 데이터 충돌이 발생할 가능성이 적습니다.
3. **병렬성 활용**: 멀티코어 시스템에서는 각 프로세스가 다른 코어에서 동시에 실행될 수 있으므로 CPU 자원을 최대로 활용하여 병렬 처리를 극대화할 수 있습니다.

### 3. 멀티 프로세스의 단점

1. **오버헤드**: 프로세스 간 독립성을 유지하기 위해, 프로세스가 생성되거나 종료될 때 많은 시스템 자원이 사용됩니다. 특히, 프로세스 간 데이터 교환 시 복잡한 통신 방식이 필요하며, 그로 인해 성능 저하가 발생할 수 있습니다.
2. **프로세스 간 통신의 복잡성**: 멀티 프로세스 환경에서는 데이터 공유가 직접적으로 불가능하므로, IPC 메커니즘을 통해 데이터를 주고받아야 합니다. 이 과정은 복잡하고 성능에 부정적인 영향을 미칠 수 있습니다.
3. **메모리 사용량 증가**: 각 프로세스가 독립된 메모리 공간을 사용하기 때문에 메모리 사용량이 많아집니다. 대규모 멀티 프로세스를 사용하는 경우, 메모리 자원이 빨리 고갈될 수 있습니다.

### 4. 멀티 프로세스의 예시

멀티 프로세스는 웹 서버, 데이터베이스 서버, 컴파일러 등 다양한 시스템에서 사용됩니다. 웹 서버의 경우, 각각의 클라이언트 요청을 별도의 프로세스로 처리함으로써 병렬 처리를 구현합니다.

#### 예시: `fork()`와 `exec()`를 사용한 멀티 프로세스
C 언어에서 멀티 프로세스를 구현할 때, `fork()`를 사용하여 자식 프로세스를 생성하고, `exec()`를 사용하여 다른 프로그램을 실행할 수 있습니다.

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid;

    // 새로운 프로세스를 생성
    pid = fork();

    if (pid == 0) {
        // 자식 프로세스: 새로운 프로그램 실행
        printf("This is the child process.\n");
        execlp("/bin/ls", "ls", (char *)NULL);  // ls 명령어 실행
    } else if (pid > 0) {
        // 부모 프로세스: 자식 프로세스가 끝날 때까지 대기
        wait(NULL);
        printf("Child process finished.\n");
    } else {
        printf("Fork failed!\n");
    }

    return 0;
}
```

- 이 코드는 `fork()`로 자식 프로세스를 생성한 후, 자식 프로세스에서 `ls` 명령어를 실행합니다. 부모 프로세스는 자식이 종료될 때까지 `wait()`로 대기합니다.

### 5. 멀티 프로세스의 활용 사례

#### 5.1. 웹 서버
웹 서버는 다중 사용자의 요청을 처리할 때 멀티 프로세스를 사용합니다. 각 클라이언트의 요청은 별도의 프로세스로 처리되며, 이를 통해 서버는 병렬로 여러 요청을 처리할 수 있습니다. 예를 들어, **Apache** 웹 서버는 새로운 클라이언트 요청이 들어올 때마다 새로운 프로세스를 생성하여 요청을 처리합니다.

#### 5.2. 데이터베이스 서버
데이터베이스 서버도 멀티 프로세스를 사용하여 여러 클라이언트의 질의(query)를 동시에 처리합니다. **PostgreSQL** 같은 데이터베이스 시스템은 클라이언트의 질의를 각기 다른 프로세스로 처리하여 성능을 높이고, 장애가 발생하더라도 다른 프로세스에 영향을 주지 않도록 합니다.

#### 5.3. 컴파일러
컴파일러는 코드를 컴파일할 때 여러 프로세스를 동시에 사용하여 코드의 여러 부분을 병렬로 처리할 수 있습니다. 특히 대규모 프로젝트에서는 파일 단위로 병렬 컴파일을 수행하여 컴파일 시간을 크게 줄일 수 있습니다.

### 6. 멀티 프로세스와 멀티 스레드 비교

- **멀티 프로세스**: 프로세스마다 독립된 메모리 공간을 사용하고, 서로 간섭하지 않습니다. 안정성이 높지만, 메모리 사용이 많고 프로세스 간 통신이 복잡합니다.
- **멀티 스레드**: 하나의 프로세스 내에서 여러 스레드가 실행됩니다. 스레드들은 메모리를 공유하기 때문에 통신이 간단하지만, 공유 자원을 사용하는 과정에서 동기화 문제가 발생할 수 있습니다. 

멀티 프로세스는 주로 안정성과 독립성이 중요한 상황에서 사용되며, 멀티 스레드는 성능과 자원 공유가 중요한 상황에서 사용됩니다.

---

### 요약

- **멀티 프로세스**는 여러 프로세스가 동시에 실행되며, 각 프로세스는 독립적인 메모리 공간을 가지고 병렬로 작업을 처리합니다.
- 멀티코어 시스템에서 성능을 극대화할 수 있으며, 하나의 프로세스가 비정상 종료되더라도 다른 프로세스에는 영향을 주지 않는 안정성을 제공합니다.
- 다만, 메모리 사용량이 크고, 프로세스 간 통신이 복잡하다는 단점이 있습니다.
- 웹 서버, 데이터베이스 서버 등에서 병렬 처리를 위해 자주 사용됩니다.