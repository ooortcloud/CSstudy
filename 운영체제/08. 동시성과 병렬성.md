## 동시성 vs 병렬성
### 동시성(병행성, Cuncurrency)
여러 개의 작업이 동시에 작동하는 것처럼 보이지만, 사실은 하나의 코어(단일 프로세서)가 여러 작업을 빠르게 번갈아가면서 처리하는 성질. 단일 프로세스만으로도 동시에 여러 작업을 병행하며 진행할 수 있기 때문에 효율적인 작업 처리가 가능해진다. 하지만 CPU 스케줄링이 강제됨으로써 구현 난이도가 높아지며, 작업이 전환될 때마다 항상 문맥 전환이 발생하게 되는 문제점이 있다. 일반적으로 개인 컴퓨팅 환경에서 자주 쓰인다.

### 병렬성(Parallelism)
두 개 이상의 프로세스들이 동시에 존재하고, 여러 개의 코어(다중 프로세서)가 병렬적으로 실행하는 성질. 정말 물리적으로 병렬 처리가 가능해짐으로써 연산 성능을 극대화시킬 수 있다. 하지만 그만큼 하드웨어 스펙을 구성하기 위한 비용이 크게 요구되며, 실제 병렬 연산을 처리하기 위한 구현도 까다롭다는 문제점이 있다. 일반적으로 대규모 처리를 수행해야 하는 슈퍼 컴퓨팅 환경에서 자주 쓰인다.

[멀티코어에 대해 알아보기](./세부%20개념/멀티코어.md)

### 비교

| **특징**        | **동시성 (Concurrency)**                    | **병렬성 (Parallelism)**                    |
|-----------------|--------------------------------------------|---------------------------------------------|
| **기본 개념**   | 여러 작업을 **교대로 실행**하여 다루는 것  | 여러 작업을 **동시에 실행**하는 것           |
| **작업 실행 방식** | **단일 프로세서**에서 시간 분할을 통해 여러 작업을 **번갈아 실행** | **여러 프로세서** 또는 코어에서 작업을 **동시에 실행** |
| **핵심 목표**   | 시스템의 **응답성**과 **작업 관리** 향상    | 작업을 **실제 동시에 실행**하여 **처리 성능** 향상 |
| **처리 환경**   | **멀티스레드** 환경에서의 작업 관리         | **멀티코어 CPU**나 **분산 시스템**에서 사용 |
| **장점**        | - 자원을 **효율적으로 사용**해 여러 작업을 처리 가능<br>- 단일 프로세서에서도 **다중 작업** 처리 가능<br>- 사용자에게 **다중 작업**이 진행 중인 느낌 제공 | - **실제 동시에** 작업을 처리해 **성능 극대화**<br>- CPU 코어나 노드가 많을수록 작업 처리 속도 향상<br>- 대규모 데이터 처리 및 계산에 효과적 |
| **단점**        | - 여러 작업이 동시에 실행되는 것은 아니며, **작업 간 대기 시간**이 존재할 수 있음<br>- 교착 상태나 **경쟁 상태**가 발생할 위험<br>- **스케줄링**이 복잡해질 수 있음 | - **하드웨어 자원** 요구가 큼 (멀티코어, 멀티프로세서 등)<br>- 데이터 간 **의존성**이 있는 경우, 병렬 실행이 어렵거나 비효율적<br>- 병렬성을 제대로 활용하기 위한 **설계와 구현**이 복잡 |

### 요약된 장단점 설명
- **동시성(Concurrency)**
  - **장점**: **단일 프로세서** 환경에서도 여러 작업을 효율적으로 관리할 수 있으며, 시스템의 **응답성**을 높이고 **다중 작업 수행의 느낌**을 줄 수 있습니다.
  - **단점**: 실제로 작업을 동시에 수행하는 것은 아니기 때문에, 각 작업 간의 **대기 시간이 존재**할 수 있으며, 여러 스레드가 자원에 접근하면서 **경쟁 상태**나 **데드락**과 같은 동기화 문제가 발생할 수 있습니다.

- **병렬성(Parallelism)**
  - **장점**: **여러 작업을 동시에 실행**하여 성능을 크게 향상시킬 수 있으며, 특히 **대규모 연산**이나 **데이터 처리**에 강력한 장점을 가집니다. 여러 코어나 프로세서를 사용하는 환경에서 병렬성을 통해 **처리 시간을 단축**할 수 있습니다.
  - **단점**: 병렬 처리를 위해서는 **멀티코어 프로세서**나 **분산 시스템**과 같은 하드웨어 자원이 필요하며, 병렬화할 수 없는 **데이터 간 의존성**이 있는 작업에서는 비효율적일 수 있습니다. 또한 병렬성을 제대로 활용하기 위해서는 복잡한 **설계와 구현**이 필요합니다.

동시성과 병렬성은 서로 관련이 있지만 다른 개념으로, **동시성**은 여러 작업이 마치 동시에 이루어지는 듯한 **시간 관리와 작업 조정**에 중점을 두며, **병렬성**은 실제로 여러 작업을 **동시에 수행**하는 것에 중점을 둡니다. 따라서 특정 상황에 따라 적합한 방법을 선택해야 합니다.


### 경쟁 조건 (Race Condition)
여러 스레드가 동시에 공유 자원에 접근할 때, 스레드 간의 실행 순서에 따라 결과가 달라지는 현상을 말합니다. 공유 자원을 적절히 동기화하지 않으면, 예기치 않은 결과가 발생할 수 있습니다. 동기화 문제의 가장 핵심적인 문제다.

[자세히 알아보기](./세부%20개념/경쟁조건.md)

### 교착 상태 (Deadlock)
두 개 이상의 프로세스 또는 스레드가 서로 상대방의 자원을 기다리면서, 어느 쪽도 진행할 수 없는 상태. 즉, **두 개 이상의 작업이 서로의 작업이 끝나기를 기다리면서 무한정 대기하게 되는 상황**이다. 교착 상태는 동시에 여러 자원을 사용해야 하는 문제를 해결하기 위한 솔루션에서 발생하는 문제이다.

**교착 상태의 발생 조건 (Deadlock의 4가지 조건)**
1. **상호 배제(Mutual Exclusion)**: 자원은 한 번에 한 프로세스만 사용할 수 있어야 합니다.
2. **점유 대기(Hold and Wait)**: 프로세스가 **자원을 점유**한 상태에서 **다른 자원을 기다리는 상황**이 발생합니다.
3. **비선점(Non-preemption)**: 프로세스가 점유한 자원을 **강제로 뺏을 수 없어야** 합니다.
4. **순환 대기(Circular Wait)**: 프로세스들이 **서로 자원을 기다리며** 원형으로 대기하는 상황입니다. (순환 대기 사이클이 존재해야 함.)

이 네 가지 조건이 동시에 만족되면 교착 상태가 발생할 수 있습니다.

**교착 상태 예시**

교착 상태를 쉽게 이해할 수 있는 간단한 예로, **두 개의 스레드**가 각각 **두 개의 자원을 사용**하려 할 때 교착 상태가 발생할 수 있습니다.

```java
public class DeadlockExample {
    // 두 개의 자원을 정의
    private static final Object resource1 = new Object();
    private static final Object resource2 = new Object();

    public static void main(String[] args) {
        // thread1은 Thread 클래스의 생성자를 사용하여 람다 표현식(()->{})으로 정의된 익명 Runnable 객체를 전달받는다.
        Thread thread1 = new Thread(() -> {
            // resource1을 잠그는 동기화 블록. thread1이 이 블록에 진입하면 다른 스레드가 resource1을 사용할 수 없다.
            synchronized (resource1) {
                System.out.println("Thread 1: resource 1 locked");

                // 스레드를 100 밀리초 동안 멈추게 하여 교착 상태를 유도한다. 잠깐의 지연이 없으면 다른 스레드가 자원을 획득할 시간적 여유가 없어 교착 상태가 발생하지 않을 수도 있다.
                try { Thread.sleep(100); } catch (InterruptedException e) {}

                System.out.println("Thread 1: waiting for resource 2...");
                // thread1이 resource2를 잠그려 시도하는 부분. 만약 resource2가 다른 스레드에 의해 이미 잠금된 상태라면 thread1은 이 자원에 대해 대기하게 된다.
                synchronized (resource2) {
                    System.out.println("Thread 1: resource 2 locked");
                }
            }
        });

        // 스레드 2
        Thread thread2 = new Thread(() -> {
            synchronized (resource2) {
                System.out.println("Thread 2: resource 2 locked");

                // 잠시 대기하여 교착 상태 유도
                try { Thread.sleep(100); } catch (InterruptedException e) {}

                System.out.println("Thread 2: waiting for resource 1...");
                // resource1은 이미 thread1에 의해 잠금된 상태이므로 thread2는 이 자원을 기다리며 멈추게 된다.
                synchronized (resource1) {
                    System.out.println("Thread 2: resource 1 locked");
                }
            }
        });

        // 두 스레드를 거의 동시에 실행한다. 
        // 각각 대기 시간을 가진 후, 두 스레드는 서로 상대방이 잠근 자원을 기다리기 시작하면서 교착 상태에 빠진다. 이 상태에서 두 스레드는 영원히 실행되지 않고 멈춘 상태가 됩니다.
        thread1.start();
        thread2.start();
    }
}
```

**설명**
1. **스레드 1**은 `resource1`을 먼저 잠그고, 그 후에 `resource2`를 잠그려고 시도합니다.
2. **스레드 2**는 `resource2`를 먼저 잠그고, 그 후에 `resource1`을 잠그려고 시도합니다.
3. **스레드 1**은 `resource1`을 점유한 상태에서 `resource2`가 잠기기를 기다리고, 동시에 **스레드 2**는 `resource2`를 점유한 상태에서 `resource1`이 잠기기를 기다립니다.
4. 이 상태에서 두 스레드는 **서로를 기다리며 진행할 수 없는 교착 상태**에 빠집니다.

이 예시에서 **`synchronized` 블록**은 Java에서 임계 영역을 설정하여 특정 자원을 보호하기 위한 방법입니다. 하지만 자원 사용 순서가 잘못되면 교착 상태가 발생할 수 있습니다.

**교착 상태 방지 방법**

교착 상태를 방지하기 위해서는 다음과 같은 전략을 사용할 수 있습니다:
1. **자원 할당 순서를 정해둠**: 모든 스레드가 자원을 **항상 같은 순서로 요청**하게 하여, 순환 대기가 발생하지 않도록 합니다.
2. **타임아웃 적용**: 스레드가 일정 시간 동안 자원을 기다리다가 **타임아웃**이 발생하면 기다림을 포기하도록 합니다.
3. **공정한 자원 사용 정책**: 각 스레드가 자원을 **점유하는 순서**나 **우선순위**를 공정하게 설정하여, 한 스레드가 자원을 영구적으로 점유하지 않도록 합니다.
4. **데드락 탐지 및 해결 알고리즘**: 시스템이 주기적으로 데드락을 탐지하고, 데드락이 발생하면 **특정 스레드를 종료하거나** 자원을 강제로 회수하는 방법을 사용할 수 있습니다.

**요약**
- **교착 상태**는 여러 프로세스가 서로 상대방의 자원을 기다리면서 발생하는 문제입니다.
- Java에서는 `synchronized`를 통해 자원을 보호할 수 있지만, 자원 사용 순서나 방식에 따라 교착 상태가 발생할 수 있습니다.
- 교착 상태를 방지하기 위해 **자원 할당 순서**를 지정하거나 **타임아웃**을 설정하는 등 다양한 해결 방법이 있습니다.


## 동기화 (Synchronization) 문제
동기화란 서로 알고 있는 정보들을 일치시키고 작업들 사이의 수행 시기를 맞추는 것이다. 여러 스레드가 공유 자원에 동시에 접근할 때, 경쟁상태에 의해 충돌이나 잘못된 작업이 일어나지 않도록 주의해서 프로그램을 작성해야 한다. 

### 뮤텍스(Mutex)

하나의 시점에 하나의 스레드 또는 프로세스만 공유 자원에 접근할 수 있도록 잠금(Lock)을 거는 방식. 뮤텍스를 사용하여 공유 자원에 접근하는 코드 영역을 임계 구역(critical section)으로 지정할 수 있습니다. 락을 해제하지 않으면 다른 스레드가 자원에 접근할 수 없습니다.

> **임계 구역(Critical Section)**: 동시 접근하려고 하는 자원(자료구조 또는 장치)에서 문제가 발생하지 않게 독점을 보장해줘야 하는 코드 영역. 임계 구역은 지정된 시간이 지난 후 종료되므로, 준비 상태의 스레드(태스크 또는 프로세스)가 임계 구역에 들어가고자 한다면 지정된 시간만큼 대기해야 한다. '공유변수 영역'이라고도 부른다.

```c
#include <stdio.h>
#include <pthread.h>

int shared_data = 0;
pthread_mutex_t lock;

void* thread_function(void* arg) {
    pthread_mutex_lock(&lock);  // 뮤텍스 잠금
    shared_data++;
    printf("Shared data: %d\n", shared_data);
    pthread_mutex_unlock(&lock);  // 뮤텍스 잠금 해제
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&lock, NULL);  // 뮤텍스 초기화
    
    pthread_create(&t1, NULL, thread_function, NULL);
    pthread_create(&t2, NULL, thread_function, NULL);
    
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    pthread_mutex_destroy(&lock);  // 뮤텍스 소멸
    return 0;
}
```

- `pthread_mutex_lock()`과 `pthread_mutex_unlock()`을 통해 임계 구역을 설정하여, 한 번에 하나의 스레드만 자원에 접근할 수 있도록 합니다.

### 세마포어(Semaphore)
정해진 수의 스레드 또는 프로세스(여기서는 스레드를 기준으로 작성하겠음)가 동시에 자원에 접근할 수 있도록 하는 동기화 기법. 자원에 접근할 수 있는 스레드의 최대 수를 지정할 수 있으며, 이를 통해 임계 구역의 동시성을 제어합니다. 세마포어는 크게 카운팅 세마포어와 이진 세마포어로 나뉘는데, 일반적으로 세마포어라고 하면 카운팅 세마포어를 지칭한다. 특정 자원의 사용 가능한 스레드의 개수를 지정해두고, 스레드가 자원을 사용하기 시작할 때마다 카운트를 하나씩 제거한다. 카운트가 0이 되면 다시 1 이상이 되기 전까지는 더 이상 다른 스레드에게 자원 사용을 허가하지 않는다. 작업 중인 스레드가 자원 사용을 그만두거나 포기할 때마다, 카운트가 다시 1씩 증가한다. 한편 이진 세마포어는 카운트가 0과 1만 가지는 경우를 말하며, 뮤텍스와 비슷한 성격을 띈다.

세마포어는 아래 두 가지 연산을 기반으로 동작하는 구조를 갖는다.
- **wait()**: 'P연산'이라고도 부른다. 자원을 사용하려는 스레드 또는 프로세스의 진입 여부를 카운트를 통해 결정한다. 사용 결정이 될 때마다 카운트를 1씩 감소시킨다.
- **signal()**: 'notify()' 또는 'V연산'이라고도 부른다. 대기 중인 스레드 또는 프로세스를 깨우는 신호이다. 카운트를 1 증가시키며 자원 반납을 알린다.

참고로 뮤텍스와는 달리 'lock'에 대한 개념이 직접적으로는 존재하지 않는다. 그저 카운트로 자원의 개방 여부를 결정할 뿐이다. 그래서 자원 소유권에 대한 개념은 존재하지 않는다.

```c
struct semaphore {
    int count;
    queueType queue;
};

void semWait (semaphore s) {
    s.count--;
    if (s.count <= 0) {
    	// 락이 걸리고 공유 자원에 접근할 수 없음
    }
} 

void semSignal (semaphore s) {
    s.count++;
    if (s.count <= 0) {
    	// 아직 락에 걸려 대기중인 프로세스가 있음
    }
}
```

### 비교

| **특징**        | **뮤텍스 (Mutex)**               | **세마포어 (Semaphore)**              |
|-----------------|----------------------------------|---------------------------------------|
| **기본 개념**   | 단일 스레드만 자원에 접근하도록 하는 **락** | 자원의 개수를 제한하여 여러 스레드가 자원에 접근할 수 있도록 하는 **카운터** |
| **자원 접근 수** | **1개** (단일 스레드만 접근 가능) | **N개** (최대 N개의 스레드가 접근 가능) |
| **타입**        | 이진 값(락, 언락)                | 카운팅 또는 이진                      |
| **사용 목적**   | 자원의 **독점적 접근** 보장       | **동시 접근 제한** 관리              |
| **동기화 목적** | **뮤텍스**는 주로 단일 스레드의 접근 보장이 필요할 때 사용 | **세마포어**는 공유 자원의 **동시 접근 제한**에 사용 |
| **상태**        | **소유(Owner)**의 개념이 존재하며, 소유한 스레드만 해제 가능 | 소유 개념이 없으며, 자원을 **신호**를 통해 주고받음 |
| **장점**        | - 단일 스레드의 독점적 자원 접근 보장<br>- 코드가 간단하고 직관적<br>- 데드락 회피를 위한 상태 관리 용이 | - 여러 자원의 접근을 관리할 수 있어 유연함<br>- **읽기-쓰기**와 같이 자원에 따라 접근이 필요한 상황에서 효율적<br>- 특정 자원에 대해 **동시 접근을 제한**할 수 있음 |
| **단점**        | - 오직 **하나의 스레드**만 접근 가능해 자원 활용 비효율적<br>- 자원 소유권으로 인해 데드락 발생 가능<br>- 병렬 처리에 제약이 있음 | - 잘못된 사용(예: 해제 시 소유자가 아닌 다른 스레드)으로 인해 **데이터 불일치** 위험<br>- **자원 관리 복잡성 증가**<br>- 잘못된 설계로 인한 **경쟁 상태** 발생 가능성 |

- **뮤텍스(Mutex)**
  - **장점**: 단일 스레드의 자원 접근을 보장하므로 **데이터 일관성**을 유지하기에 적합하고, 코드 구조가 간단하여 직관적인 구현이 가능합니다.
  - **단점**: 하나의 스레드만 접근할 수 있어 **병렬성**이 제한되며, 자원 소유권으로 인해 **데드락**이 발생할 위험이 있습니다.

- **세마포어(Semaphore)**
  - **장점**: 여러 스레드가 자원에 동시에 접근할 수 있는 상황에서 유용하며, 자원의 **동시 접근 제어**가 가능합니다. 특히 **카운팅 세마포어**는 자원의 개수를 제한하면서도 효율적으로 사용을 조절할 수 있습니다.
  - **단점**: 세마포어의 잘못된 사용으로 **데이터 불일치**가 발생할 수 있으며, 신호를 관리하는 것이 복잡하여 자원 접근에 대한 설계가 까다롭습니다.

뮤텍스와 세마포어는 각기 다른 상황에서 사용되며, 자원의 사용 패턴과 접근 동시성을 고려하여 적절히 선택하는 것이 중요합니다.

### 모니터(Monitor)

뮤텍스와 세마포어의 성질을 결합하여 공유 자원을 보호하는 일종의 고수준 동기화 도구로 자원에 접근하는 코드를 묶어서 관리한다. Java와 C#에서 자주 사용되며, 객체의 임계 구역을 설정해 해당 구역에 대해 스레드 간 배타적 접근을 보장한다. 

**모니터의 구조**
- 내부 락(Mutex 락): 모니터 내부에서 자원에 접근하는 코드 블록을 보호하기 위해 뮤텍스 락을 사용합니다. 자원에 접근하기 전에 락을 걸고, 접근이 끝나면 락을 해제합니다.
- 조건 변수(Condition Variable): 모니터는 조건 변수를 사용해 자원에 접근할 수 없는 스레드를 대기 상태로 만들고, 특정 조건이 만족되면 해당 스레드를 깨워 작업을 재개할 수 있도록 합니다. 이는 세마포어의 wait/signal 연산과 유사한 기능을 합니다.
- 자동 관리: 모니터는 락과 조건 변수의 사용을 자동으로 관리하여, 개발자가 직접 락을 제어하거나 조건을 설정하지 않아도 되는 장점이 있습니다. 이를 통해 코드의 간결함과 안전성이 높아집니다.

모니터를 사용하면 뮤텍스와 세마포어를 굳이 구현하지 않고도 동시성 문제를 해결할 수 있어 개발 생산성이 높아진다는 장점이 있다. 하지만 뮤텍스 성질을 가짐으로써 병렬 처리에는 한계가 있으며, 조건 변수가 영원히 만족하지 못하면 교착상태에 빠지는 문제도 여전히 피할 수 없게 된다. 이렇게 뮤텍스와 세마포어의 모든 단점을 갖는다는 단점을 가짐에도 불구하고 그것을 상쇄할 정도로 개발 생산성이 높아지기 때문에, 수많은 개발자들이 모니터를 사용하여 동기성 문제를 해결하고 있다.

[모니터에 대해 자세히 알아보기](./세부%20개념/모니터.md)

## Thread-safe : 동기화 문제 해결 방법

**Thread-safe**란 여러 스레드가 동시에 하나의 공유 자원에 접근하더라도 **데이터 손상**이나 **비정상적인 동작**이 발생하지 않도록 설계된 코드를 의미합니다. 즉, 스레드 간에 안전하게 데이터를 공유하고 동기화 문제를 방지하는 것이 thread-safe의 핵심입니다.

멀티 스레드 환경에서 **thread-safe하지 않으면**, 두 개 이상의 스레드가 동시에 동일한 자원에 접근하면서 **경쟁 조건(race condition)**이나 **데이터 손실**이 발생할 수 있습니다. 이를 막기 위해 thread-safe 코드를 작성하는 방법이 필요합니다.

### Thread-safe 설계 방법

#### (1) **상호 배제(Mutual Exclusion, Mutex)**
스레드가 자원을 공유할 때, 다른 스레드가 동시에 해당 자원에 접근하지 못하도록 막는 방법. 주로 **락(Lock)**을 사용해 구현하며 락을 걸어 자원에 대한 **독점적 접근**을 보장한다. 한편 뮤텍스의 비교군인 세마포어 방식은 일반적으로 2개 이상의 스레드가 동시 접근할 수 있도록 허용하기 때문에 thread-safe한 방법은 아니다.

```java
// Java의 synchronized 키워드를 사용한 thread-safe 설계
public synchronized void increment() {
    count++;
}
```

- **스핀락(Spinlock)**: 락이 해제될 때까지 계속해서 자원에 접근을 시도하는 방식입니다. 짧은 시간 안에 락이 해제될 것으로 예상될 때 유용하지만, 오랜 시간 락이 걸려 있으면 성능에 문제가 생길 수 있습니다.

#### (2) **원자성(Atomicity) 보장**
하나의 작업을 더 이상 쪼갤 수 없는 단위로 만들어, 중간에 인터럽트가 발생하지 않도록 보장하는 방식입니다. **원자 연산(Atomic Operation)**은 여러 스레드가 동시에 실행해도 결과가 일관되게 유지됩니다.

- **Atomic 변수**: Java의 `java.util.concurrent.atomic` 패키지에는 `AtomicInteger`, `AtomicLong` 등 원자성을 보장하는 변수들이 제공됩니다. 이 변수들은 내부적으로 락을 걸지 않고도 동시성 문제를 해결할 수 있습니다.

```java
AtomicInteger atomicCount = new AtomicInteger(0);
atomicCount.incrementAndGet(); // 원자적으로 증가
```

#### (3) **불변 객체(Immutable Object) 사용**
**불변 객체(Immutable Object)**는 **한 번 생성된 이후에 그 상태가 변경되지 않는 객체**를 의미합니다. 즉, 객체의 모든 필드나 상태가 초기화된 이후에는 절대로 수정할 수 없고 내부 데이터도 변하지 않습니다. **불변성(immutability)**은 동시성 문제를 방지하는 데 유용하며, 불변 객체는 thread-safe(스레드 간의 안전한 공유)를 보장합니다.

**불변 객체의 특성**
1. **상태 변경 불가**: 객체가 생성된 이후에는 그 상태(필드 값)를 바꿀 수 없습니다.
2. **새로운 객체 생성**: 상태를 변경하고 싶다면, 기존 객체를 수정하는 대신 **새로운 객체를 생성**해야 합니다.
3. **스레드 안전성(Thread Safety)**: 불변 객체는 상태가 변경되지 않기 때문에 **동기화 없이도** 여러 스레드가 안전하게 공유할 수 있습니다.
4. **생성 시점에 완전한 초기화**: 모든 필드가 객체가 생성될 때 완전히 초기화되며, 이후 그 값을 바꿀 수 없습니다.

**Java에서 불변 객체의 예: `String` 클래스**

Java의 **`String` 클래스**는 대표적인 **불변 객체**입니다. `String` 객체가 한 번 생성되면 그 내부 데이터(문자열 내용)는 변경될 수 없습니다. 

**예시 1: `String`의 불변성**
```java
public class ImmutableExample {
    public static void main(String[] args) {
        String str = "Hello";    // String 객체 생성
        String newStr = str.concat(" World");  // 새로운 String 객체 생성
        
        System.out.println("Original: " + str);    // "Hello"
        System.out.println("Modified: " + newStr); // "Hello World"
    }
}
```

**설명**
- **`str`** 변수는 `"Hello"` 값을 가지는 **`String` 객체**를 참조합니다.
- **`concat()`** 메서드는 `" World"`를 기존 문자열에 **덧붙이는 메서드**입니다. 하지만 기존의 `str`은 수정되지 않고, **새로운 `String` 객체**인 `"Hello World"`가 생성되어 **`newStr`** 변수가 이를 참조하게 됩니다.
- `str`은 여전히 `"Hello"` 상태를 유지합니다. 이것이 **불변성**의 핵심입니다.

**예시 3: String 객체 변경**
```java
public class StringComparison {
    public static void main(String[] args) {
        String str1 = "Hello";
        String str2 = "Hello";
        str2 = "World";

        System.out.println(str1);  // Hello
        System.out.println(str2);  // World
    }
}
```

**설명**



**예시 2: String 객체 비교**
```java
public class StringComparison {
    public static void main(String[] args) {
        String str1 = "Hello";
        String str2 = "Hello";

        System.out.println(str1 == str2);  // false
        System.out.println(str1.equals(str2));  // true
    }
}
```

**설명**
- 문자열 리터럴 `"Hello"`는 **불변**이기 때문에, 동일한 문자열 리터럴이 여러 번 사용되더라도 **Java는 새로운 객체를 생성하지 않고** **기존 객체를 재사용**합니다. 따라서 `str1`과 `str2`는 **같은 객체를 참조**하게 됩니다.
- 이는 **메모리 절약** 및 **성능 향상**에 도움을 주며, 불변 객체의 장점 중 하나입니다.

**불변 객체를 만드는 방법**
불변 객체를 만들려면 다음 규칙을 따릅니다:
1. **모든 필드는 `final`로 선언**: 객체 생성 후 필드를 수정할 수 없도록 `final` 키워드를 사용합니다.
2. **생성자에서 필드를 초기화**: 필드는 반드시 객체가 생성될 때 초기화되어야 합니다.
3. **변경 가능한 필드를 외부에서 접근하지 못하도록 보호**: 변경 가능한 객체를 필드로 사용할 경우, 해당 필드를 **클론**하거나 **불변 버전으로** 저장해야 합니다.
4. **setter 메서드 금지**: 필드 값을 변경할 수 있는 setter 메서드를 제공하지 않습니다.

**불변 객체 예시:**
```java
public final class ImmutablePerson {
    private final String name;
    private final int age;

    public ImmutablePerson(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // getter만 제공, setter는 없음
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}
```

**설명**
- `ImmutablePerson` 클래스는 불변 객체입니다. 
- **모든 필드는 `final`**로 선언되어 있어, 한 번 값이 설정되면 더 이상 변경할 수 없습니다.
- **getter만 제공**하고, 필드를 수정하는 setter는 없습니다.

**불변 객체의 장단점**

| 장점                                    | 단점                                      |
|---------------------------------------|-----------------------------------------|
| **스레드 안전성**: 동기화 없이 여러 스레드에서 안전하게 사용할 수 있음.  | 새로운 상태를 반영하기 위해 **새 객체**를 만들어야 해서 성능 이슈 발생 가능. |
| **단순함**: 불변 상태이므로 코드의 복잡성을 줄이고, 디버깅이 쉬움.   | 상태가 자주 변경되는 객체라면 **메모리 사용량**이 늘어날 수 있음. |
| **버그 방지**: 상태가 변경되지 않으므로, 의도치 않은 수정이나 사이드 이펙트가 없음. | **객체 복사**가 빈번하게 발생할 수 있음. |
| **참조 투명성**: 불변 객체는 **참조 투명성**을 유지, 같은 입력이면 항상 같은 결과를 반환. | 성능이 중요한 상황에서는 **가변 객체**보다 비효율적일 수 있음. |


#### (4) **Thread-local 저장소 사용**
스레드별로 독립된 데이터를 관리하기 위한 방법으로, **Thread-local 저장소**를 사용하면 각 스레드가 다른 스레드와 독립된 변수 공간을 가질 수 있습니다. 각 스레드는 자신의 복사본을 사용하여 공유 자원에 접근하므로 동기화가 필요하지 않습니다.

- **ThreadLocal 클래스**: Java에서는 `ThreadLocal` 클래스를 통해 각 스레드가 자신만의 변수를 가질 수 있도록 설정할 수 있습니다.

```java
ThreadLocal<Integer> threadLocalVar = new ThreadLocal<>();
threadLocalVar.set(100); // 각 스레드별로 독립된 값 사용
```

#### (5) **동기화된 컬렉션 사용**
Java와 C++에서는 **동기화된 컬렉션**을 제공하여 여러 스레드가 동시에 데이터를 추가하거나 삭제해도 안전하도록 보장합니다. Java의 경우, `Collections.synchronizedList()` 같은 방법으로 동기화된 컬렉션을 사용할 수 있습니다.

```java
List<Integer> synchronizedList = Collections.synchronizedList(new ArrayList<>());
```

또한, Java의 **동시성 컬렉션(Concurrent Collections)**인 `ConcurrentHashMap`, `ConcurrentLinkedQueue` 등은 더욱 효율적으로 멀티 스레드 환경에서 안전하게 사용할 수 있습니다.

#### (6) **락 프리(lock-free) 알고리즘**
락을 사용하지 않고도 공유 자원을 안전하게 처리할 수 있는 **락 프리 알고리즘**을 사용하는 방식입니다. 이 방식은 주로 낮은 수준의 프로그래밍에서 사용되며, CPU의 원자적 연산을 활용합니다. 예를 들어 **CAS(Compare-And-Swap)**는 자원의 상태를 비교하고 조건에 맞으면 값을 교체하는 방식으로 동작합니다.

### Thread-safe 설계 시 고려 사항

**동기화 범위 최소화**
동기화된 코드의 범위가 넓어질수록 **성능 저하**가 발생할 수 있습니다. 따라서, 최소한의 범위만 동기화하여 불필요한 락 경쟁을 피하는 것이 중요합니다.

**데드락(Deadlock) 피하기**
동기화된 코드에서 자원 순서에 따라 교착 상태가 발생할 수 있습니다. 여러 락을 사용해야 하는 상황이라면, **자원 획득 순서를 고정**하거나 **타임아웃**을 설정해 데드락을 방지해야 합니다.

**스레드 간의 데이터 일관성 보장**
공유 데이터에 여러 스레드가 접근할 때 **일관성**을 보장하는 것도 중요합니다. 메모리 가시성 문제를 해결하기 위해 **메모리 배리어(memory barrier)**나 **volatile** 키워드를 사용해 최신 데이터를 항상 확인할 수 있도록 해야 합니다.

**언어별 Thread-safe 지원**

- **Java**: `synchronized`, `volatile`, `Atomic` 클래스, `ThreadLocal`, 동시성 컬렉션 등 다양한 thread-safe 도구를 제공.
- **C/C++**: POSIX 스레드(Pthread) 라이브러리를 통해 뮤텍스, 세마포어, 원자적 연산 등 thread-safe 기능 제공.
- **Python**: `threading` 모듈에서 락(`Lock`), `RLock` 등을 제공하며, `queue.Queue` 같은 thread-safe 자료 구조도 지원.
- **C#**: `lock` 키워드로 상호 배제를 지원하며, `Monitor`, `Mutex`, `Semaphore`, `ConcurrentDictionary` 등의 도구도 사용 가능.
