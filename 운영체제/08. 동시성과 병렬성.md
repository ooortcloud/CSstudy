## 동시성 vs 병렬성
### 동시성(병행성, Cuncurrency)
여러 개의 작업이 동시에 작동하는 것처럼 보이지만, 사실은 하나의 코어(단일 프로세서)가 여러 작업을 빠르게 번갈아가면서 처리하는 성질. 동시성으로 다중 작업을 처리하는 경우, 작업이 전환될 때마다 항상 문맥 전환이 발생하게 된다.

### 병렬성(Parallelism)
두 개 이상의 프로세스들이 동시에 존재하고, 여러 개의 코어(다중 프로세서)가 병렬적으로 실행하는 성질. 

[멀티코어에 대해 알아보기](./세부%20개념/멀티코어.md)

### 비교

동시성과 병렬성을 비교하고, 각각의 장단점을 쉽게 이해할 수 있도록 **테이블 형식**으로 요약해 보겠습니다.

| **특징**        | **동시성 (Concurrency)**                    | **병렬성 (Parallelism)**                    |
|-----------------|--------------------------------------------|---------------------------------------------|
| **기본 개념**   | 여러 작업을 **교대로 실행**하여 다루는 것  | 여러 작업을 **동시에 실행**하는 것           |
| **작업 실행 방식** | **단일 프로세서**에서 시간 분할을 통해 여러 작업을 **번갈아 실행** | **여러 프로세서** 또는 코어에서 작업을 **동시에 실행** |
| **핵심 목표**   | 시스템의 **응답성**과 **작업 관리** 향상    | 작업을 **실제 동시에 실행**하여 **처리 성능** 향상 |
| **처리 환경**   | **멀티스레드** 환경에서의 작업 관리         | **멀티코어 CPU**나 **분산 시스템**에서 사용 |
| **장점**        | - 자원을 **효율적으로 사용**해 여러 작업을 처리 가능<br>- 단일 프로세서에서도 **다중 작업** 처리 가능<br>- 사용자에게 **다중 작업**이 진행 중인 느낌 제공 | - **실제 동시에** 작업을 처리해 **성능 극대화**<br>- CPU 코어나 노드가 많을수록 작업 처리 속도 향상<br>- 대규모 데이터 처리 및 계산에 효과적 |
| **단점**        | - 여러 작업이 동시에 실행되는 것은 아니며, **작업 간 대기 시간**이 존재할 수 있음<br>- 교착 상태나 **경쟁 상태**가 발생할 위험<br>- **스케줄링**이 복잡해질 수 있음 | - **하드웨어 자원** 요구가 큼 (멀티코어, 멀티프로세서 등)<br>- 데이터 간 **의존성**이 있는 경우, 병렬 실행이 어렵거나 비효율적<br>- 병렬성을 제대로 활용하기 위한 **설계와 구현**이 복잡 |

### 요약된 장단점 설명
- **동시성(Concurrency)**
  - **장점**: **단일 프로세서** 환경에서도 여러 작업을 효율적으로 관리할 수 있으며, 시스템의 **응답성**을 높이고 **다중 작업 수행의 느낌**을 줄 수 있습니다.
  - **단점**: 실제로 작업을 동시에 수행하는 것은 아니기 때문에, 각 작업 간의 **대기 시간이 존재**할 수 있으며, 여러 스레드가 자원에 접근하면서 **경쟁 상태**나 **데드락**과 같은 동기화 문제가 발생할 수 있습니다.

- **병렬성(Parallelism)**
  - **장점**: **여러 작업을 동시에 실행**하여 성능을 크게 향상시킬 수 있으며, 특히 **대규모 연산**이나 **데이터 처리**에 강력한 장점을 가집니다. 여러 코어나 프로세서를 사용하는 환경에서 병렬성을 통해 **처리 시간을 단축**할 수 있습니다.
  - **단점**: 병렬 처리를 위해서는 **멀티코어 프로세서**나 **분산 시스템**과 같은 하드웨어 자원이 필요하며, 병렬화할 수 없는 **데이터 간 의존성**이 있는 작업에서는 비효율적일 수 있습니다. 또한 병렬성을 제대로 활용하기 위해서는 복잡한 **설계와 구현**이 필요합니다.

동시성과 병렬성은 서로 관련이 있지만 다른 개념으로, **동시성**은 여러 작업이 마치 동시에 이루어지는 듯한 **시간 관리와 작업 조정**에 중점을 두며, **병렬성**은 실제로 여러 작업을 **동시에 수행**하는 것에 중점을 둡니다. 따라서 특정 상황에 따라 적합한 방법을 선택해야 합니다.

## Thread safe

**Thread-safe**란 여러 스레드가 동시에 하나의 공유 자원에 접근하더라도, **데이터 손상**이나 **비정상적인 동작**이 발생하지 않도록 설계된 코드를 의미합니다. 즉, 스레드 간에 안전하게 데이터를 공유하고, 동기화 문제를 방지하는 것이 thread-safe의 핵심입니다.

멀티 스레드 환경에서 **thread-safe하지 않으면**, 두 개 이상의 스레드가 동시에 동일한 자원에 접근하면서 **경쟁 조건(race condition)**이나 **데이터 손실**이 발생할 수 있습니다. 이를 막기 위해 thread-safe 코드를 작성하는 방법이 필요합니다.

### 경쟁 조건 (Race Condition)
여러 스레드가 동시에 공유 자원에 접근할 때, 스레드 간의 실행 순서에 따라 결과가 달라지는 현상을 말합니다. 공유 자원을 적절히 동기화하지 않으면, 예기치 않은 결과가 발생할 수 있습니다.

[자세히 알아보기](./세부%20개념/경쟁조건.md)

### 동기화 (Synchronization)
서로 알고 있는 정보들을 일치시키고 작업들 사이의 수행 시기를 맞추는 것. 여러 스레드가 공유 자원에 동시에 접근할 때, 경쟁상태에 의해 충돌이나 잘못된 작업이 일어나지 않도록 주의해서 프로그램을 작성해야 한다. 

#### 뮤텍스(Mutex)

하나의 시점에 하나의 스레드 또는 프로세스만 공유 자원에 접근할 수 있도록 잠금(Lock)을 거는 방식. 뮤텍스를 사용하여 공유 자원에 접근하는 코드 영역을 임계 구역(critical section)으로 지정할 수 있습니다. 락을 해제하지 않으면 다른 스레드가 자원에 접근할 수 없습니다.

> **임계 구역(Critical Section)**: 동시 접근하려고 하는 자원(자료구조 또는 장치)에서 문제가 발생하지 않게 독점을 보장해줘야 하는 코드 영역. 임계 구역은 지정된 시간이 지난 후 종료되므로, 준비 상태의 스레드(태스크 또는 프로세스)가 임계 구역에 들어가고자 한다면 지정된 시간만큼 대기해야 한다. '공유변수 영역'이라고도 부른다.

```c
#include <stdio.h>
#include <pthread.h>

int shared_data = 0;
pthread_mutex_t lock;

void* thread_function(void* arg) {
    pthread_mutex_lock(&lock);  // 뮤텍스 잠금
    shared_data++;
    printf("Shared data: %d\n", shared_data);
    pthread_mutex_unlock(&lock);  // 뮤텍스 잠금 해제
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&lock, NULL);  // 뮤텍스 초기화
    
    pthread_create(&t1, NULL, thread_function, NULL);
    pthread_create(&t2, NULL, thread_function, NULL);
    
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    
    pthread_mutex_destroy(&lock);  // 뮤텍스 소멸
    return 0;
}
```

- `pthread_mutex_lock()`과 `pthread_mutex_unlock()`을 통해 임계 구역을 설정하여, 한 번에 하나의 스레드만 자원에 접근할 수 있도록 합니다.

#### 세마포어(Semaphore)
정해진 수의 스레드 또는 프로세스가 동시에 자원에 접근할 수 있도록 하는 동기화 기법. 자원에 접근할 수 있는 스레드의 최대 수를 지정할 수 있으며, 이를 통해 임계 구역의 동시성을 제어합니다.

```c
struct semaphore {
    int count;
    queueType queue;
};

void semWait (semaphore s) {
    s.count--;
    if (s.count <= 0) {
    	// 락이 걸리고 공유 자원에 접근할 수 없음
    }
} 

void semSignal (semaphore s) {
    s.count++;
    if (s.count <= 0) {
    	// 아직 락에 걸려 대기중인 프로세스가 있음
    }
}
```

#### 비교

뮤텍스와 세마포어의 비교를 쉽게 이해할 수 있도록 **각각의 장단점을 테이블**로 요약해 보겠습니다.

| **특징**        | **뮤텍스 (Mutex)**               | **세마포어 (Semaphore)**              |
|-----------------|----------------------------------|---------------------------------------|
| **기본 개념**   | 단일 스레드만 자원에 접근하도록 하는 **락** | 자원의 개수를 제한하여 여러 스레드가 자원에 접근할 수 있도록 하는 **카운터** |
| **자원 접근 수** | **1개** (단일 스레드만 접근 가능) | **N개** (최대 N개의 스레드가 접근 가능) |
| **타입**        | 이진 값(락, 언락)                | 카운팅 또는 이진                      |
| **사용 목적**   | 자원의 **독점적 접근** 보장       | **동시 접근 제한** 관리              |
| **소유권**      | 락을 획득한 **스레드만 해제** 가능 | 락을 획득한 스레드와 다른 스레드가 해제 가능 |
| **동기화 목적** | **뮤텍스**는 주로 단일 스레드의 접근 보장이 필요할 때 사용 | **세마포어**는 공유 자원의 **동시 접근 제한**에 사용 |
| **상태**        | **소유(Owner)**의 개념이 존재하며, 소유한 스레드만 해제 가능 | 소유 개념이 없으며, 자원을 **신호**를 통해 주고받음 |
| **장점**        | - 단일 스레드의 독점적 자원 접근 보장<br>- 코드가 간단하고 직관적<br>- 데드락 회피를 위한 상태 관리 용이 | - 여러 자원의 접근을 관리할 수 있어 유연함<br>- **읽기-쓰기**와 같이 자원에 따라 접근이 필요한 상황에서 효율적<br>- 특정 자원에 대해 **동시 접근을 제한**할 수 있음 |
| **단점**        | - 오직 **하나의 스레드**만 접근 가능해 자원 활용 비효율적<br>- 자원 소유권으로 인해 데드락 발생 가능<br>- 병렬 처리에 제약이 있음 | - 잘못된 사용(예: 해제 시 소유자가 아닌 다른 스레드)으로 인해 **데이터 불일치** 위험<br>- **자원 관리 복잡성 증가**<br>- 잘못된 설계로 인한 **경쟁 상태** 발생 가능성 |

- **뮤텍스(Mutex)**
  - **장점**: 단일 스레드의 자원 접근을 보장하므로 **데이터 일관성**을 유지하기에 적합하고, 코드 구조가 간단하여 직관적인 구현이 가능합니다.
  - **단점**: 하나의 스레드만 접근할 수 있어 **병렬성**이 제한되며, 자원 소유권으로 인해 **데드락**이 발생할 위험이 있습니다.

- **세마포어(Semaphore)**
  - **장점**: 여러 스레드가 자원에 동시에 접근할 수 있는 상황에서 유용하며, 자원의 **동시 접근 제어**가 가능합니다. 특히 **카운팅 세마포어**는 자원의 개수를 제한하면서도 효율적으로 사용을 조절할 수 있습니다.
  - **단점**: 세마포어의 잘못된 사용으로 **데이터 불일치**가 발생할 수 있으며, 신호를 관리하는 것이 복잡하여 자원 접근에 대한 설계가 까다롭습니다.

뮤텍스와 세마포어는 각기 다른 상황에서 사용되며, 자원의 사용 패턴과 접근 동시성을 고려하여 적절히 선택하는 것이 중요합니다.

#### 모니터(Monitor)

뮤텍스와 세마포어의 성질을 결합하여 공유 자원을 보호하는 일종의 고수준 동기화 도구로, 자원에 접근하는 코드를 묶어서 관리한다. 뮤텍스와 동일한 성질로는 동시에 하나의 스레드만 접근 가능하다는 점이며, 세마포어와 동일한 성질로는 특정 조건이 만족되면 대기 중인 스레드를 깨운다는 점이다. Java와 C#에서 자주 사용되며, 객체의 임계 구역을 설정해 해당 구역에 대해 스레드 간 배타적 접근을 보장한다. 

**모니터의 구조**
- 내부 락(Mutex 락): 모니터 내부에서 자원에 접근하는 코드 블록을 보호하기 위해 뮤텍스 락을 사용합니다. 자원에 접근하기 전에 락을 걸고, 접근이 끝나면 락을 해제합니다.
- 조건 변수(Condition Variable): 모니터는 조건 변수를 사용해 자원에 접근할 수 없는 스레드를 대기 상태로 만들고, 특정 조건이 만족되면 해당 스레드를 깨워 작업을 재개할 수 있도록 합니다. 이는 세마포어의 wait/signal 연산과 유사한 기능을 합니다.
- 자동 관리: 모니터는 락과 조건 변수의 사용을 자동으로 관리하여, 개발자가 직접 락을 제어하거나 조건을 설정하지 않아도 되는 장점이 있습니다. 이를 통해 코드의 간결함과 안전성이 높아집니다.

모니터를 사용하면 뮤텍스와 세마포어를 굳이 구현하지 않고도 동시성 문제를 해결할 수 있어 개발 생산성이 높아진다는 장점이 있다. 하지만 뮤텍스 성질을 가짐으로써 병렬 처리에는 한계가 있으며, 조건 변수가 영원히 만족하지 못하면 교착상태에 빠지는 문제도 여전히 피할 수 없게 된다. 이렇게 뮤텍스와 세마포어의 모든 단점을 갖는다는 단점을 가짐에도 불구하고 그것을 상쇄할 정도로 개발 생산성이 높아지기 때문에, 수많은 개발자들이 모니터를 사용하여 동기성 문제를 해결하고 있다.

[모니터에 대해 자세히 알아보기](./세부%20개념/모니터.md)

### 교착 상태 (Deadlock)
여러 스레드가 서로 자원을 기다리면서, 더 이상 실행을 진행할 수 없는 상태입니다. 두 개 이상의 스레드가 서로가 가진 자원을 요구하면서 무한정 대기 상태에 빠지는 상황을 교착 상태라고 합니다.

### 기아 상태 (Starvation)
특정 스레드가 자원을 지속적으로 얻지 못해 실행이 무한히 지연되는 상태를 말합니다. 다른 스레드가 계속해서 우선권을 가지면 기아 상태가 발생할 수 있습니다.

### Thread-safe 설계 방법

#### (1) **상호 배제(Mutual Exclusion)**
스레드가 자원을 공유할 때, 다른 스레드가 동시에 해당 자원에 접근하지 못하도록 막는 방법입니다. 주로 **락(Lock)**을 사용해 구현하며, 락을 걸어 자원에 대한 **독점적 접근**을 보장합니다.

```java
// Java의 synchronized 키워드를 사용한 thread-safe 설계
public synchronized void increment() {
    count++;
}
```

- **스핀락(Spinlock)**: 락이 해제될 때까지 계속해서 자원에 접근을 시도하는 방식입니다. 짧은 시간 안에 락이 해제될 것으로 예상될 때 유용하지만, 오랜 시간 락이 걸려 있으면 성능에 문제가 생길 수 있습니다.

#### (2) **원자성(Atomicity) 보장**
하나의 작업을 더 이상 쪼갤 수 없는 단위로 만들어, 중간에 인터럽트가 발생하지 않도록 보장하는 방식입니다. **원자 연산(Atomic Operation)**은 여러 스레드가 동시에 실행해도 결과가 일관되게 유지됩니다.

- **Atomic 변수**: Java의 `java.util.concurrent.atomic` 패키지에는 `AtomicInteger`, `AtomicLong` 등 원자성을 보장하는 변수들이 제공됩니다. 이 변수들은 내부적으로 락을 걸지 않고도 동시성 문제를 해결할 수 있습니다.

```java
AtomicInteger atomicCount = new AtomicInteger(0);
atomicCount.incrementAndGet(); // 원자적으로 증가
```

#### (3) **불변 객체(Immutable Object) 사용**
불변 객체는 한 번 생성되면 내부 상태가 변하지 않는 객체로, 여러 스레드에서 동시에 읽기 작업을 해도 상태가 바뀌지 않아 thread-safe합니다. 불변 객체는 멀티스레드 환경에서 동기화 문제를 피할 수 있는 안전한 방법입니다.

- **String 객체**: 예를 들어, Java의 `String` 객체는 불변 객체로 설계되어 있기 때문에 여러 스레드에서 공유하더라도 안전합니다.

```java
String str = "immutable";  // 한 번 생성된 후 변경되지 않음
```

#### (4) **Thread-local 저장소 사용**
스레드별로 독립된 데이터를 관리하기 위한 방법으로, **Thread-local 저장소**를 사용하면 각 스레드가 다른 스레드와 독립된 변수 공간을 가질 수 있습니다. 각 스레드는 자신의 복사본을 사용하여 공유 자원에 접근하므로 동기화가 필요하지 않습니다.

- **ThreadLocal 클래스**: Java에서는 `ThreadLocal` 클래스를 통해 각 스레드가 자신만의 변수를 가질 수 있도록 설정할 수 있습니다.

```java
ThreadLocal<Integer> threadLocalVar = new ThreadLocal<>();
threadLocalVar.set(100); // 각 스레드별로 독립된 값 사용
```

#### (5) **동기화된 컬렉션 사용**
Java와 C++에서는 **동기화된 컬렉션**을 제공하여 여러 스레드가 동시에 데이터를 추가하거나 삭제해도 안전하도록 보장합니다. Java의 경우, `Collections.synchronizedList()` 같은 방법으로 동기화된 컬렉션을 사용할 수 있습니다.

```java
List<Integer> synchronizedList = Collections.synchronizedList(new ArrayList<>());
```

또한, Java의 **동시성 컬렉션(Concurrent Collections)**인 `ConcurrentHashMap`, `ConcurrentLinkedQueue` 등은 더욱 효율적으로 멀티 스레드 환경에서 안전하게 사용할 수 있습니다.

#### (6) **락 프리(lock-free) 알고리즘**
락을 사용하지 않고도 공유 자원을 안전하게 처리할 수 있는 **락 프리 알고리즘**을 사용하는 방식입니다. 이 방식은 주로 낮은 수준의 프로그래밍에서 사용되며, CPU의 원자적 연산을 활용합니다. 예를 들어 **CAS(Compare-And-Swap)**는 자원의 상태를 비교하고 조건에 맞으면 값을 교체하는 방식으로 동작합니다.

### 2. Thread-safe 설계 시 고려 사항

#### (1) **동기화 범위 최소화**
동기화된 코드의 범위가 넓어질수록 **성능 저하**가 발생할 수 있습니다. 따라서, 최소한의 범위만 동기화하여 불필요한 락 경쟁을 피하는 것이 중요합니다.

#### (2) **데드락(Deadlock) 피하기**
동기화된 코드에서 자원 순서에 따라 교착 상태가 발생할 수 있습니다. 여러 락을 사용해야 하는 상황이라면, **자원 획득 순서를 고정**하거나 **타임아웃**을 설정해 데드락을 방지해야 합니다.

#### (3) **스레드 간의 데이터 일관성 보장**
공유 데이터에 여러 스레드가 접근할 때 **일관성**을 보장하는 것도 중요합니다. 메모리 가시성 문제를 해결하기 위해 **메모리 배리어(memory barrier)**나 **volatile** 키워드를 사용해 최신 데이터를 항상 확인할 수 있도록 해야 합니다.

### 3. 언어별 Thread-safe 지원

- **Java**: `synchronized`, `volatile`, `Atomic` 클래스, `ThreadLocal`, 동시성 컬렉션 등 다양한 thread-safe 도구를 제공.
- **C/C++**: POSIX 스레드(Pthread) 라이브러리를 통해 뮤텍스, 세마포어, 원자적 연산 등 thread-safe 기능 제공.
- **Python**: `threading` 모듈에서 락(`Lock`), `RLock` 등을 제공하며, `queue.Queue` 같은 thread-safe 자료 구조도 지원.
- **C#**: `lock` 키워드로 상호 배제를 지원하며, `Monitor`, `Mutex`, `Semaphore`, `ConcurrentDictionary` 등의 도구도 사용 가능.
