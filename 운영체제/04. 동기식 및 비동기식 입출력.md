동기식 입출력(Synchronous I/O)과 비동기식 입출력(Asynchronous I/O)은 컴퓨터 시스템에서 데이터 입출력 작업을 처리하는 두 가지 주요 방식입니다. 이 두 방식은 입출력 작업이 수행되는 동안 CPU가 어떻게 반응하고 처리하는지를 구분합니다.

### 1. 동기식 입출력 (Synchronous I/O)

**동기식 입출력**은 입출력 작업이 완료될 때까지 CPU가 해당 작업을 기다리는 방식입니다. 즉, 입출력 작업이 끝날 때까지 프로그램 실행이 중단되며, 작업이 완료된 후에야 다음 명령어로 넘어갈 수 있습니다.

#### 특징

- **블로킹(Blocking) 방식**: 동기식 입출력은 일반적으로 블로킹 방식으로 구현됩니다. CPU는 입출력 작업이 완료될 때까지 기다리며, 이 동안 다른 작업을 수행하지 않습니다.
  
- **단순성**: 동기식 입출력은 구현이 비교적 단순합니다. 코드 흐름이 순차적이어서 입출력 작업의 순서와 결과를 예측하기 쉽습니다.

- **사용 사례**: 동기식 입출력은 간단한 프로그램이나 입출력 작업이 빠르게 완료될 수 있는 경우에 적합합니다. 예를 들어, 소규모 파일 읽기/쓰기를 수행하는 경우에는 동기식 입출력을 사용해도 시스템 성능에 큰 영향을 주지 않습니다.

#### 동작 방식

1. **입출력 요청**: 프로그램에서 파일 읽기/쓰기 등의 입출력 작업을 요청합니다.
2. **CPU 대기**: 입출력 장치가 데이터를 처리하고, 작업이 완료될 때까지 CPU는 대기 상태에 있습니다.
3. **작업 완료 후 진행**: 입출력 작업이 완료되면 CPU는 대기 상태에서 벗어나 다음 명령어를 실행합니다.

#### 예시

```python
file = open("data.txt", "r")  # 파일 열기
data = file.read()            # 파일을 읽고 데이터 가져오기 (이 동안 CPU는 대기)
process(data)                 # 읽어온 데이터를 처리
```

위 코드에서 `file.read()`가 완료될 때까지 CPU는 대기합니다. 파일 읽기가 끝나야만 `process(data)`로 넘어갑니다.

### 2. 비동기식 입출력 (Asynchronous I/O)

**비동기식 입출력**은 입출력 작업이 진행되는 동안 CPU가 해당 작업을 기다리지 않고, 다른 작업을 계속 수행하는 방식입니다. 입출력 작업이 완료되면, CPU는 특정 이벤트나 인터럽트를 통해 작업 완료를 인지하고, 필요한 후속 작업을 수행합니다.

#### 특징

- **논블로킹(Non-blocking) 방식**: 비동기식 입출력은 일반적으로 논블로킹 방식으로 구현됩니다. CPU는 입출력 작업이 완료되기를 기다리지 않으며, 다른 작업을 수행할 수 있습니다.
  
- **복잡성**: 비동기식 입출력은 동기식에 비해 구현이 복잡합니다. 작업 완료 시점을 알기 위해 콜백(callback), 이벤트, 또는 인터럽트와 같은 메커니즘이 필요합니다.

- **사용 사례**: 비동기식 입출력은 대용량 데이터를 처리하거나, 입출력 작업이 오래 걸리는 경우에 유용합니다. 예를 들어, 서버에서 여러 클라이언트의 요청을 동시에 처리해야 할 때 비동기식 입출력을 사용하면 효율적입니다.

[콜백 함수와 이벤트 기반 처리](./참고문서/콜백함수와%20이벤트기반처리.md)

[인터럽트](./세부%20개념/인터럽트.md)

#### 동작 방식

1. **입출력 요청**: 프로그램에서 입출력 작업을 요청합니다.
2. **작업 진행 중 CPU는 다른 작업 수행**: CPU는 입출력 작업이 완료되기를 기다리지 않고, 다른 작업을 계속 수행합니다.
3. **작업 완료 통지**: 입출력 작업이 완료되면, 콜백 함수나 인터럽트를 통해 CPU에 알립니다.
4. **후속 작업 수행**: 작업 완료 통지를 받은 CPU는 후속 작업을 수행합니다.

#### 예시

```python
import asyncio

async def read_file():
    file = await open_async("data.txt", "r")  # 비동기적으로 파일 열기
    data = await file.read()                  # 파일 읽기 (이 동안 CPU는 다른 작업 수행 가능)
    process(data)                             # 읽어온 데이터를 처리

asyncio.run(read_file())
```

위 코드에서 `await file.read()`는 비동기적으로 파일을 읽습니다. 이 동안 CPU는 다른 작업을 수행할 수 있으며, 파일 읽기가 완료되면 `process(data)`로 넘어갑니다.

### 3. 동기식 입출력 vs 비동기식 입출력

#### **응답 속도**
- **동기식 입출력**: 입출력 작업이 완료될 때까지 대기하므로 응답 속도가 느릴 수 있습니다.
- **비동기식 입출력**: CPU가 다른 작업을 병행할 수 있어 응답 속도가 빠릅니다.

#### **시스템 자원 활용**
- **동기식 입출력**: CPU가 입출력 작업 동안 아무런 작업도 하지 못하므로 자원 활용이 비효율적일 수 있습니다.
- **비동기식 입출력**: CPU가 입출력 작업 동안 다른 작업을 수행할 수 있어 자원 활용이 효율적입니다.

#### **복잡성**
- **동기식 입출력**: 구현이 간단하며, 코드의 흐름이 명확합니다.
- **비동기식 입출력**: 구현이 복잡하며, 작업 완료 시점을 처리하는 코드가 필요합니다.

#### **적합한 사용 사례**
- **동기식 입출력**: 단순한 입출력 작업, 응답 속도가 중요하지 않은 경우.
- **비동기식 입출력**: 서버에서 여러 클라이언트의 요청을 동시에 처리해야 하는 경우, 대량의 데이터를 처리하는 경우.

### 4. 결론

동기식 입출력과 비동기식 입출력은 각각의 장단점이 있으며, 상황에 맞게 선택하여 사용해야 합니다. 시스템 성능과 응답성을 높이기 위해서는 입출력 작업의 특성과 프로그램의 요구 사항을 고려하여 적절한 방식을 선택하는 것이 중요합니다.
