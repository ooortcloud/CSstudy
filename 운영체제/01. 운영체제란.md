## 정의
> 컴퓨터 전반적인 HW와 SW를 관리하고 사용자와 컴퓨터 간 '인터페이스' 역할을 하는 특별한 '프로그램'

Operation System(OS). 운영체제는 근본적으로 SW이다. HW와 같이 딸려오는 물리적인 요소라고 생각하면 큰 착각을 할 수 있다. 하다못해 HW 자체에 직접적으로 탑재된 SW인 '펌웨어(firmware)'라는 HW에 더 직접적인 다른 SW 유형이 있는 만큼, 운영체제는 완벽히 SW적인 성향을 띄고 있다고 봐야 한다. 대신 우리가 직관적으로 사용이 가능한 응용 SW가 아닌, 컴퓨터를 관리해주는 시스템 SW에 해당한다.

Windows, macOS, Linux, Android, iOS 등 이러한 것들이 모두 운영체제이다.

## 목적
1. 사용자에게 HW를 조작할 수 있는 '인터페이스'를 제공하여, 사용자가 편리하게 시스템을 이용할 수 있도록 도움
2. 시스템 자원을 효율적으로 관리하여 응용 프로그램의 성능을 높임

OS는 사용자가 직접 명령을 내리는 대상이 아니라, 사용자 뒤에서 보조해주는 비서의 역할에 가깝다.

## 주요 기능

1. **프로세스 관리**: 여러 프로그램이 동시에 실행될 수 있도록 각 프로세스의 실행을 관리합니다. 프로세스 스케줄링을 통해 CPU 시간을 효율적으로 배분하여 여러 작업을 동시에 처리하는 멀티태스킹을 지원합니다.

2. **메모리 관리**: 시스템의 메모리를 관리하고 각 프로그램이 메모리를 효율적으로 사용할 수 있도록 합니다. 운영체제는 가상 메모리를 통해 물리적 메모리보다 더 많은 메모리를 사용할 수 있도록 해줍니다.

3. **파일 시스템 관리**: 데이터 파일을 저장, 조직, 접근, 수정할 수 있도록 파일 시스템을 제공합니다. 파일의 읽기, 쓰기, 삭제 등의 작업을 수행하고, 디스크의 공간을 관리합니다.

4. **디바이스 관리**: 컴퓨터의 하드웨어 장치를 관리하고, 사용자가 키보드, 마우스, 프린터, 디스크 드라이브 등 다양한 장치를 사용할 수 있도록 합니다. 장치 드라이버를 통해 하드웨어와 소프트웨어 간의 통신을 처리합니다.

5. **사용자 인터페이스 제공**: 사용자와 컴퓨터 간의 상호작용을 위해 그래픽 사용자 인터페이스(GUI) 또는 명령줄 인터페이스(CLI)를 제공합니다. 이를 통해 사용자는 프로그램을 실행하거나 파일을 관리할 수 있습니다.

6. **보안 및 접근 제어**: 시스템 자원을 보호하고 사용자 접근을 제어하는 보안 기능을 제공합니다. 운영체제는 사용자 계정을 관리하고, 권한을 설정하여 파일 및 데이터의 무단 접근을 방지합니다.

각종 시스템을 내부적으로 알아서 관리해주는 것이 주요 기능이고, 보안적인 사항들을 잘 지켜주는 것이 주요 임무이다.

## 운영체제 구조
![운영체제 구조](<../이미지 폴더/OpertationSystemStructure.png>)

컴퓨터의 전반적인 구조는 위 이미지와 같이 구성되어 있다. 

### 응용프로그램 및 유틸리티
사용자들이 end point에서 사용하는 최종 SW 프로그램 또는 도구를 총칭하는 layer. 

### 미들웨어 (Middleware)
운영체제와 응용 프로그램 사이에서 중개자 역할을 하는 프로그램.

### 운영체제
**인터페이스**
커널에 사용자의 명령을 전달하고, 그것의 실행 결과를 사용자에게 알려주는 역할을 수행함.

**커널**
운영체제의 주요 기능들을 수행하는 핵심 영역. 커널의 대표적인 구성 요소로 '시스템콜'과 '드라이버'가 있다. 시스템콜을 통해 사용자의 명령을 이해하고, 드라이버를 통해 하드웨어에 명령을 수행한다. 그리고 하드웨어의 수행 결과를 역방향으로 받아들이면서 미들웨어에 수행 결과를 알려주고, 최종적으로 사용자가 수행 결과를 알 수 있도록 한다.

[커널 내용정리](./02.%20커널.md)

### 하드웨어 (Hardware)
마더보드, 그래픽 카드, 중앙처리장치(CPU), 환기용 팬, 웹캠, 전원 공급 장치 등을 포함하여 PC 또는 노트북 내에서 작동하는 회로 기판에 있는 모든 것을 총칭한다. 컴퓨터 구조 과목에서 이 HW의 구체적인 요소들과 작동 방식을 직접적으로 다룬다.

## 운영체제 유형
1. 일괄처리(batch) 시스템 (1950년대 ~ 1960년대 초반):
   - 최초의 상용 컴퓨터 시스템에서 사용 (이때부터 천공카드로부터 벗어남)
   - 작업들을 그룹으로 모아 순차적으로 처리
   - 사용자 상호작용 없이 자동으로 작업 실행
   - 일괄처리 시스템의 문제 :: CPU 유휴 시간이 많아 비효율적 (입출력 작업 시간 동안 CPU가 계속 idle 상태. CPU는 빠른데 IO가 느려서 발생하는 문제.)

2. 다중 프로그래밍 시스템 (1960년대 중반):
   - CPU 사용률 향상을 위해 도입
   - 여러 프로그램을 메모리에 동시에 올려 실행
   - I/O 대기 시간 동안 다른 프로그램 실행
   - 자원 활용도 증가, 처리량 향상
   - 다중 프로그래밍 시스템의 문제 :: CPU 스케줄링, 메모리 관리, 메모리 영역 보호

3. 대화형(시분할)(interactive) 시스템 (1960년대 후반):
   - 사용자가 컴퓨터와 실시간으로 상호작용할 수 있는 인터렉티브 장치의 등장 (모니터, 키보드 등)
   - 여러 사용자가 동시에 시스템 사용 가능 (정작 사용자 개인은 혼자서 쓰는 중이라고 느껴짐)
   - CPU 시간을 작은 단위로 나누어 프로그램들에 할당
   - 사용자에게 빠른 응답 시간 제공
   - 대화식 프로그래밍 환경 지원 (사용자에게 즉각적인 피드백 제공)

4. 다중 처리 시스템 (1970년대):
   - 여러 개의 CPU를 사용하여 병렬 처리
   - 작업 부하 분산 및 시스템 신뢰성 향상
   - 대규모 계산 작업에 적합
   - 복잡한 스케줄링 알고리즘 필요

5. 실시간 처리 시스템 (RTOS, RealTime OS) (1970년대 ~ 1980년대):
   - 정해진 시간 내에 작업 완료 보장
   - 경성 실시간 시스템과 연성 실시간 시스템으로 구분
   - 공장 자동화, 항공 제어 시스템, 미사일 제어, 은행 입출금 등 특수한 목적에 사용
   - 예측 가능성과 신뢰성이 중요 (처리의 결과가 현재의 결정에 영향을 줌)

6. 분산 처리 시스템 (1980년대 이후):
   - 네트워크로 연결된 여러 컴퓨터가 협력하여 작업 처리
   - 자원 공유 및 부하 분산 가능
   - 클라이언트-서버 모델, 클라우드 컴퓨팅으로 발전
   - 확장성과 fault tolerance 향상

이러한 운영체제 유형들은 서로 독립적으로 발전한 것이 아니라, 이전 유형의 장점을 계승하고 단점을 보완하며 발전해 왔습니다. 현대의 운영체제들은 이러한 여러 유형의 특성을 복합적으로 가지고 있으며, 사용 목적에 따라 특정 특성이 더 강조되기도 합니다.

예를 들어, 현대의 개인용 컴퓨터 운영체제는 다중 프로그래밍, 시분할, 다중 처리 시스템의 특성을 모두 가지고 있으며, 서버용 운영체제는 여기에 분산 처리 시스템의 특성까지 포함하고 있습니다. 임베디드 시스템에서는 실시간 처리 시스템의 특성이 중요하게 다뤄지고 있습니다.

이 발전 과정에서 각 운영체제 유형은 이전 유형의 한계를 극복하고, 컴퓨터 하드웨어의 발전과 사용자 요구사항의 변화를 반영하며 진화해 왔습니다.

## 컴퓨터 부팅 과정(Booting)
1. 전원 공급 (Power On):
   - 전원 버튼을 누르면 전원 공급 장치(Power Supply Unit)가 작동
   - 메인보드와 다른 하드웨어 컴포넌트에 전력 공급

2. POST (Power-On Self-Test):
   - 비휘발성 장치인 ROM(Read-Only Memory)에는 'POST'와 '부트 로더' 두 프로그램들이 설치되어 있음
   - 전원이 켜지면 CPU(Centrel Process Unit)은 ROM에 있는 내용들을 전부 읽어들임
   - BIOS/UEFI 펌웨어가 실행
   - 기본적인 하드웨어 검사 수행 (CPU, 메모리, 저장 장치 등)
   - 문제 발견 시 경고음 또는 오류 메시지 출력

3. BIOS/UEFI 초기화:
   - 시스템 설정 로드
   - 하드웨어 초기화 및 구성

4. 부트 장치 선택:
   - BIOS/UEFI가 부팅 순서에 따라 부트 가능한 장치 검색
   - 보통 하드 디스크, SSD, USB 드라이브, CD/DVD 등

5. 부트로더(Boot Loader) 로딩:
   - 선택된 부트 장치의 MBR(Master Boot Record) 또는 GPT(GUID Partition Table)에서 부트로더 로드
   - 예: GRUB, LILO, Windows Boot Manager

6. 운영체제 커널 로딩:
   - 부트로더는 부트 장치에 저장되어 있는 운영체제 프로그램을 찾아서 RAM(Random Access Memory)에 운영체제 프로세스를 올린다.
   - 부트로더가 커널 이미지를 메모리로 로드
   - 커널 초기화 시작

7. 커널 초기화:
   - 메모리 관리 시스템 설정
   - 장치 드라이버 로드
   - 프로세스 관리 시스템 초기화
   - 파일 시스템 마운트

8. init 프로세스 시작 (Unix/Linux 시스템인 경우):
   - PID 1번으로 init 프로세스 시작
   - 시스템 서비스 및 데몬 프로세스 실행

9. 사용자 인터페이스 로딩:
   - 그래픽 사용자 인터페이스(GUI) 또는 명령줄 인터페이스(CLI) 시작
   - 로그인 프롬프트 또는 데스크톱 환경 표시

10. 사용자 세션 시작:
    - 사용자 인증 후 개인 환경 설정 로드
    - 사용자 애플리케이션 실행 준비 완료