쿠키와 세션은 웹 애플리케이션에서 **사용자의 상태를 유지**하고 **인증**을 관리하는 데 주로 사용되는 두 가지 방식입니다. HTTP의 특성상 **비연결성**이 있기 때문에, 웹 서버는 각 요청 간에 클라이언트의 상태를 기억하지 못합니다. 이 문제를 해결하기 위해 쿠키와 세션이 사용됩니다.

[HTTP](./프로토콜/HTTP.md)

## 개념
### 1. **쿠키(Cookie)**

**쿠키**는 웹 서버가 사용자의 웹 브라우저에 저장하는 작은 데이터 조각입니다. 쿠키는 사용자가 웹 사이트를 방문할 때 서버에서 생성되어 클라이언트(브라우저) 측에 저장되며, 이후 같은 웹 사이트에 재방문할 때마다 클라이언트는 저장된 쿠키를 서버에 다시 전송합니다. 이를 통해 서버는 사용자에 대한 정보를 기억할 수 있습니다.

#### 쿠키의 주요 특징:
- **클라이언트 측 저장:** 쿠키는 클라이언트(브라우저)에 저장되며, 클라이언트가 직접 쿠키를 관리할 수 있습니다. 사용자는 브라우저에서 쿠키를 삭제하거나 차단할 수 있습니다.
- **크기 제한:** 각 쿠키의 크기는 약 4KB로 제한됩니다.
- **만료 시간:** 쿠키는 생성될 때 만료 시간(유효 기간)을 설정할 수 있습니다. 세션 쿠키는 브라우저가 종료되면 삭제되며, 영구 쿠키는 만료 시간까지 클라이언트에 저장됩니다.
- **보안 이슈:** 쿠키는 클라이언트 측에서 저장되기 때문에 악의적인 사용자가 쿠키를 조작할 수 있습니다. 이를 방지하기 위해 쿠키 데이터를 암호화하거나 **HTTPOnly**와 **Secure** 속성을 사용할 수 있습니다.
  - `HTTPOnly:` 클라이언트 측 스크립트(JavaScript 등)에서 쿠키에 접근하지 못하게 설정
  - `Secure:` HTTPS에서만 쿠키를 전송하도록 설정

#### 쿠키의 구성요소

쿠키는 웹 서버가 클라이언트(보통 웹 브라우저)에 보내는 작은 데이터 조각으로, 클라이언트는 이를 로컬에 저장하고 이후 서버와의 통신 시 다시 서버로 보냅니다. 이를 통해 웹 서버는 클라이언트의 상태를 추적하고, 사용자 맞춤형 서비스를 제공할 수 있습니다. 

쿠키는 다음과 같은 구성 요소로 이루어져 있습니다.

1. 이름 (Name)
   * 쿠키를 식별하기 위한 고유한 이름입니다.
   * 예: user_id, session_id

2. 값 (Value)
   * 이름에 해당하는 값입니다. 실제 데이터를 저장하는 부분입니다.
   * 예: 12345, "John Doe"

3. 만료 시간 (Expires)
   * 쿠키가 유효한 기간을 설정합니다.
   * 만료 시간이 설정되지 않으면 세션 쿠키가 되어 브라우저를 닫으면 삭제됩니다.
   * 특정 날짜까지 유효하도록 설정할 수 있습니다.

4. 도메인 (Domain)
   * 쿠키를 전송할 도메인을 지정합니다.
   * 예: example.com
   * 하위 도메인에도 쿠키를 전송하도록 설정할 수 있습니다.

5. 경로 (Path)
   * 쿠키를 전송할 경로를 지정합니다.
   * 예: /admin
   * 지정된 경로 이하의 모든 URL에서 쿠키가 전송됩니다.

6. 보안 (Secure)
   * HTTPS 연결에서만 쿠키를 전송하도록 설정합니다.
   * 쿠키의 내용이 암호화되어 전송되므로 보안이 중요한 정보를 저장할 때 사용합니다.

7. HTTPOnly
   * JavaScript에서 쿠키에 접근하지 못하도록 설정합니다.
   * XSS 공격으로부터 쿠키를 보호하는 데 도움이 됩니다.

8. SameSite
   * 쿠키가 어떤 요청과 함께 전송될지를 제한하는 속성입니다.
   * Cross-Site Request Forgery (CSRF) 공격을 방어하는 데 사용됩니다.
       * Strict: 다른 사이트에서의 요청에 포함되지 않습니다.
       * Lax: 대부분의 최상위 사이트 요청에 포함됩니다.
       * None: 모든 요청에 포함됩니다.

**쿠키 예시**

```
Set-Cookie: user_id=12345; Expires=Wed, 21 Oct 2023 07:28:00 GMT; Domain=example.com; Path=/; Secure; HttpOnly; SameSite=Lax
```

위 예시는 다음과 같은 의미를 가집니다.

* 쿠키 이름: user_id
* 쿠키 값: 12345
* 만료 시간: 2023년 10월 21일
* 도메인: example.com
* 경로: / (루트 경로)
* 보안: HTTPS 연결에서만 전송
* JavaScript 접근 불가
* 다른 사이트에서의 요청에는 포함되지 않음


#### 쿠키의 사용 예:
- **자동 로그인:** 사용자가 로그인할 때, 로그인 정보를 쿠키에 저장해 두면, 이후 재방문 시 로그인 상태를 유지할 수 있습니다.
- **사용자 선호 정보:** 사용자가 선택한 언어 설정, 화면 구성 등을 쿠키에 저장해 다음 방문 시 자동으로 설정된 값을 불러옵니다.

### 2. **세션(Session)**

**세션**은 사용자가 웹 서버와 상호작용하는 동안 서버 측에서 관리하는 정보 저장 방식입니다. 세션은 각 사용자에게 고유한 식별자(세션 ID)를 부여하여 사용자의 상태를 유지하고, 세션 데이터를 서버에서 저장합니다. 클라이언트는 이 세션 ID만을 쿠키나 URL에 저장하여 서버에 전송하고, 서버는 해당 ID를 통해 세션 데이터를 식별합니다.

#### 세션의 주요 특징:
- **서버 측 저장:** 세션 데이터는 서버에 저장되므로 클라이언트는 세션 ID만을 저장하게 됩니다. 서버에서 사용자의 상태나 데이터(예: 장바구니 정보)를 유지합니다.
- **보안성:** 세션은 쿠키에 비해 더 안전합니다. 클라이언트가 직접 데이터를 접근하지 않으며, 서버에서 관리되기 때문에 쿠키보다 보안에 유리합니다.
- **세션 ID 관리:** 서버는 클라이언트가 전송한 세션 ID를 통해 사용자 정보를 조회합니다. 세션 ID는 쿠키에 저장되거나 URL에 포함될 수 있습니다.
- **만료 시간:** 세션은 일정 시간이 지나면 만료됩니다. 서버는 일정 시간 동안 사용자의 요청이 없으면 세션을 삭제합니다. 이를 통해 서버 자원을 효율적으로 사용할 수 있습니다.

#### 세션의 사용 예:
- **로그인 상태 유지:** 사용자가 웹 사이트에 로그인하면, 서버는 해당 사용자에 대한 세션을 생성하고 로그인 상태를 유지합니다. 사용자가 사이트 내에서 이동하더라도 세션을 통해 로그인 상태가 유지됩니다.
- **장바구니:** 사용자가 온라인 쇼핑몰에서 상품을 선택할 때, 장바구니 정보가 세션에 저장됩니다. 세션은 서버에 저장되므로 사용자가 페이지를 이동해도 장바구니 상태가 유지됩니다.
- **개인화:** 사용자의 선호도나 방문 기록을 바탕으로 맞춤형 콘텐츠를 제공합니다.

### 3. **쿠키와 세션의 차이점**

| 항목         | **쿠키(Cookie)**                               | **세션(Session)**                            |
|--------------|-----------------------------------------------|---------------------------------------------|
| **저장 위치** | 클라이언트(브라우저)에 저장                      | 서버에 저장, 클라이언트는 세션 ID만 저장         |
| **보안**      | 클라이언트가 데이터를 수정할 수 있어 보안에 취약할 수 있음 | 서버에 저장되어 상대적으로 안전함               |
| **만료 시간** | 쿠키에 명시된 만료 시간에 따라 자동 삭제           | 사용자가 활동하지 않으면 일정 시간 후 만료       |
| **저장 용량** | 쿠키 당 최대 4KB                               | 서버에 저장되므로 저장 용량에 제한이 없음         |
| **속도**      | 클라이언트에 저장되므로 서버에 비해 상대적으로 빠름    | 서버에 저장되므로 클라이언트에 비해 상대적으로 느림 |
| **유지 방법** | 쿠키 자체에 데이터를 저장하여 유지                 | 세션 ID를 통해 서버에서 데이터를 참조하여 유지      |

### 4. **쿠키와 세션의 결합**

실제로는 **쿠키와 세션을 결합**해서 많이 사용합니다. 세션은 서버에서 데이터를 관리하고, 세션 ID만 클라이언트의 쿠키에 저장하여 서버로 전송하게 하는 방식입니다. 이렇게 하면 세션의 보안성을 유지하면서도 쿠키의 간편함을 활용할 수 있습니다.

#### 예시:
- 사용자가 웹 사이트에 로그인하면 서버는 해당 사용자에 대한 세션을 생성하고, 세션 ID를 쿠키에 저장합니다. 이후 사용자가 요청을 보낼 때마다 쿠키에 있는 세션 ID를 서버로 보내고, 서버는 이 ID를 통해 사용자의 세션 데이터를 확인하여 상태를 유지합니다.

## 동작 순서
HTTP 통신에서 쿠키와 세션을 사용한 동작 순서를 자세히 설명해 드리겠습니다:

1. 클라이언트의 최초 요청:
   - 사용자가 웹 브라우저를 통해 웹 서버에 처음으로 접속합니다.
   - 이 시점에는 클라이언트에 쿠키가 없습니다.

2. 서버의 응답 및 세션 생성:
   - 서버는 요청을 받고 새로운 세션을 생성합니다.
   - 세션 ID를 생성하고 서버의 메모리나 데이터베이스에 저장합니다.
   - 서버는 HTTP 응답 헤더에 Set-Cookie를 포함시켜 세션 ID를 클라이언트에게 전송합니다.

3. 클라이언트의 쿠키 저장:
   - 브라우저는 서버로부터 받은 Set-Cookie 헤더를 해석합니다.
   - 세션 ID를 포함한 쿠키를 브라우저의 쿠키 저장소에 저장합니다.

4. 이후 요청에서의 쿠키 전송:
   - 클라이언트가 같은 서버에 다시 요청을 보낼 때, 저장된 쿠키를 HTTP 요청 헤더에 포함시켜 전송합니다.

5. 서버의 세션 확인:
   - 서버는 요청에 포함된 쿠키에서 세션 ID를 추출합니다.
   - 추출한 세션 ID를 사용해 서버에 저장된 세션 정보를 조회합니다.

6. 세션 기반 응답:
   - 서버는 세션 정보를 바탕으로 사용자의 상태를 파악하고 적절한 응답을 생성합니다.
   - 필요한 경우 세션 정보를 업데이트합니다.

7. 세션 만료:
   - 일정 시간 동안 사용자의 활동이 없으면 서버는 세션을 만료시킵니다.
   - 만료된 세션 ID로 요청이 오면 서버는 새로운 세션을 생성하고 새 세션 ID를 발급합니다.

8. 로그아웃:
   - 사용자가 로그아웃하면 서버는 해당 세션을 삭제합니다.
   - 클라이언트의 쿠키도 삭제하거나 무효화합니다.

이 과정을 통해 서버는 stateless한 HTTP 프로토콜 상에서 사용자의 상태를 유지하고 관리할 수 있습니다. 쿠키는 클라이언트 측에서 세션 ID를 저장하고 전송하는 역할을 하며, 세션은 서버 측에서 사용자별 정보를 저장하고 관리하는 역할을 합니다.


# 세션 저장소
## 세션 저장소에 대한 설명

**세션 저장소**는 웹 애플리케이션에서 사용자의 상태 정보를 저장하는 공간입니다. 사용자가 웹사이트를 방문하여 로그인을 하거나, 장바구니에 물건을 담는 등의 행동을 할 때 이러한 정보들이 세션 저장소에 저장됩니다. 이를 통해 사용자는 웹사이트를 탐색하는 동안 자신의 정보를 유지하고, 맞춤형 서비스를 제공받을 수 있습니다.

### 세션 저장소의 종류

세션 저장소는 크게 **내부 저장소**와 **외부 저장소**로 나눌 수 있습니다.

* **내부 저장소:**
    * **메모리:** 서버의 메모리에 세션 정보를 저장하는 방식입니다. 속도가 빠르지만, 서버가 재부팅되면 세션 정보가 손실될 수 있습니다.
    * **파일 시스템:** 파일 시스템에 세션 정보를 저장하는 방식입니다. 메모리에 비해 속도가 느리지만, 서버 재부팅에도 데이터가 유지됩니다.
* **외부 저장소:**
    * **데이터베이스:** MySQL, PostgreSQL 등의 데이터베이스에 세션 정보를 저장하는 방식입니다. 확장성이 좋고 안정적이지만, 데이터베이스에 부하를 줄 수 있습니다.
    * **캐시:** Redis, Memcached 등의 캐시 서버에 세션 정보를 저장하는 방식입니다. 메모리 기반으로 속도가 빠르고, 분산 환경에서도 사용 가능합니다.

### 세션 관리 방식

* **쿠키:** 클라이언트(브라우저)에 작은 데이터를 저장하여 세션 ID를 관리하는 방식입니다.
* **URL 재작성:** URL에 세션 ID를 포함시켜 서버로 전달하는 방식입니다.
* **Hidden 필드:** HTML 폼에 숨겨진 필드에 세션 ID를 포함시켜 서버로 전달하는 방식입니다.

### 세션 저장소 선택 시 고려 사항

* **성능:** 빠른 응답 속도가 필요한 경우 메모리 기반 저장소를 선택하는 것이 좋습니다.
* **안정성:** 데이터 손실을 방지하기 위해 데이터베이스나 파일 시스템 기반 저장소를 고려해야 합니다.
* **확장성:** 많은 사용자가 동시에 접속하는 경우 분산 캐시를 활용하는 것이 좋습니다.
* **보안:** 세션 정보는 민감한 데이터를 포함할 수 있으므로, 암호화 및 접근 권한 관리를 철저히 해야 합니다.

### 세션 저장소의 장단점

| 장점 | 단점 |
|---|---|
| 사용자 상태 관리 용이 | 자원 소모가 클 수 있음 |
| 개인화 서비스 제공 가능 | 보안에 취약할 수 있음 |
| 웹 애플리케이션의 기능 확장 | 세션 관리 오버헤드 발생 |

### 결론

세션 저장소는 웹 애플리케이션에서 필수적인 구성 요소입니다. 사용자의 상태를 효과적으로 관리하여 더욱 편리하고 안전한 웹 서비스를 제공할 수 있도록 도와줍니다. 하지만 세션 저장소를 도입할 때는 시스템 환경과 요구사항에 맞는 적절한 세션 저장 방식을 선택해야 합니다.


## 외부 저장소를 포함한 동작 순서
이 방식은 서버의 메모리 부하를 줄이고 확장성을 높일 수 있는 장점이 있습니다.

1. 클라이언트의 최초 요청:
   - 사용자가 웹 브라우저를 통해 웹 서버에 처음으로 접속합니다.
   - 이 시점에는 클라이언트에 쿠키가 없습니다.

2. 서버의 응답 및 세션 생성:
   - 서버는 요청을 받고 새로운 세션 ID를 생성합니다.
   - 이 세션 ID는 유니크한 식별자(예: UUID)입니다.
   - 서버는 세션 데이터를 외부 세션 저장소(예: Redis, Memcached, 데이터베이스)에 저장합니다.
   - 저장 시 세션 ID를 키로 사용하고, 세션 데이터를 값으로 저장합니다.

3. 쿠키 설정:
   - 서버는 HTTP 응답 헤더에 Set-Cookie를 포함시켜 세션 ID를 클라이언트에게 전송합니다.
   - 예: Set-Cookie: SESSION_ID=abc123; HttpOnly; Secure

4. 클라이언트의 쿠키 저장:
   - 브라우저는 서버로부터 받은 Set-Cookie 헤더를 해석합니다.
   - 세션 ID를 포함한 쿠키를 브라우저의 쿠키 저장소에 저장합니다.

5. 이후 요청에서의 쿠키 전송:
   - 클라이언트가 같은 서버에 다시 요청을 보낼 때, 저장된 쿠키(세션 ID)를 HTTP 요청 헤더에 포함시켜 전송합니다.

6. 서버의 세션 확인:
   - 서버는 요청에 포함된 쿠키에서 세션 ID를 추출합니다.
   - 추출한 세션 ID를 사용해 외부 세션 저장소에서 세션 데이터를 조회합니다.

7. 세션 기반 응답:
   - 서버는 조회한 세션 데이터를 바탕으로 사용자의 상태를 파악하고 적절한 응답을 생성합니다.
   - 필요한 경우 세션 데이터를 업데이트하고 외부 저장소에 다시 저장합니다.

8. 세션 만료:
   - 외부 세션 저장소에서 세션 데이터에 대한 TTL(Time To Live)을 설정합니다.
   - TTL이 지나면 세션 데이터는 자동으로 삭제됩니다.
   - 만료된 세션 ID로 요청이 오면 서버는 새로운 세션을 생성하고 새 세션 ID를 발급합니다.

9. 로그아웃:
   - 사용자가 로그아웃하면 서버는 외부 세션 저장소에서 해당 세션 데이터를 삭제합니다.
   - 클라이언트의 쿠키도 삭제하거나 무효화합니다.

이 방식의 장점:
1. 서버 확장성: 세션 데이터가 외부 저장소에 있어 여러 서버 간에 세션 정보를 공유할 수 있습니다.
2. 성능: 외부 저장소(예: Redis)를 사용하면 빠른 읽기/쓰기가 가능합니다.
3. 메모리 관리: 애플리케이션 서버의 메모리 부하를 줄일 수 있습니다.
4. 지속성: 서버 재시작 시에도 세션 데이터가 유지됩니다.

주의할 점:
1. 네트워크 오버헤드: 외부 저장소와의 통신이 필요하므로 약간의 지연이 발생할 수 있습니다.
2. 복잡성: 시스템 구조가 더 복잡해질 수 있습니다.
3. 보안: 외부 저장소의 보안도 고려해야 합니다.

이 방식은 대규모 웹 애플리케이션에서 많이 사용되며, 특히 마이크로서비스 아키텍처에서 유용합니다. 